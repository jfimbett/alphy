I am developing a Next.js application for private equity funds to be able to upload documents and have them
analyzed using Large Language Models. The application allows for signup/login, and some persistence of user data.
The application is built mostly using typescript, and uses a local postgres database for storing data, as well as some local storage 
in the folder of the application for large data. A normal workflow for a user is to upload a folder with documents, 
select the documents that the users wants analyzed, then the LLM first summarizes the document, then it identifies key variablesto extract, then
it extracts that information, and finally there is a consolidation step because it can happen that the same company 
appears in different documents. 

I need your help with the following things

1. The data that is displayed in /companies/page.tsx I need it to be stored somehow. You can decide if either as  json (which makes sense since we can already see the json raw data) or as you think its more convenient. 
The reason for this is that this data needs to be also accessed through an API, so the user after having this in the website can also accessed that data through an API for his own applications. 
In order for the server to know the user requesting the data, I need in the settings page to have an API key for this. 
2. There might be a lot of json raw files being nicely displayed in companies/page.tsx, so I need the option to press a button next to every number being displayed
and this automatically will copy to the clipboard the exact url required to access that information through the API.

Here is the file structure of the project

|-- favicon.ico
|-- globals.css
|-- layout.tsx
|-- page.tsx
|-- types.ts
|-- data-aggregated
  |-- page.tsx
|-- companies
  |-- page.tsx
|-- settings
  |-- page.tsx
|-- login
  |-- page.tsx
|-- signup
  |-- page.tsx
|-- history
  |-- page.tsx
  |-- [sessionId]
    |-- page.tsx
|-- data
  |-- page.tsx
  |-- [cik]
    |-- page.tsx
|-- dashboard
  |-- page.tsx
  |-- useChat.tsx
  |-- utils
    |-- utils.tsx
|-- api
  |-- company-facts
    |-- route.tsx
  |-- account-data
    |-- route.tsx
  |-- all-accounts
    |-- route.tsx
  |-- financial-data
    |-- route.tsx
  |-- countTokens
    |-- route.tsx
  |-- llm
    |-- route.tsx
  |-- store-heavy-data
    |-- route.tsx
  |-- submission-history
    |-- route.tsx
  |-- search
    |-- route.tsx
  |-- session-file
    |-- route.tsx
  |-- test
    |-- route.tsx
  |-- files
    |-- route.tsx
    |-- [fileId]
      |-- route.tsx
  |-- auth
    |-- signup
      |-- route.tsx
    |-- login
      |-- route.tsx
  |-- sessions
    |-- route.tsx
    |-- [sessionId]
      |-- route.tsx
  |-- uploads
    |-- route.tsx
    |-- [uploadId]
      |-- route.tsx
|-- AlphyAnimation.tsx
|-- AnalysisPreview.tsx
|-- ChatMessage.tsx
|-- CompanyInfoComponent.tsx
|-- CompanySearch.tsx
|-- ExtractedTextComponent.tsx
|-- FileTree.tsx
|-- FileUploader.tsx
|-- Footer.tsx
|-- Navbar.tsx
|-- SummaryContent.tsx
|-- TestimonialsSlider.tsx
|-- dashboard
  |-- ChatSection.tsx
  |-- FileAnalysisProgress.tsx
  |-- FilePreviewSection.tsx
  |-- FileUploadArea.tsx
  |-- LoadSessionModal.tsx
  |-- ModelSelector.tsx
  |-- RadioButtons.tsx
  |-- SaveSessionModal.tsx
  |-- SessionNameModal.tsx
|-- ui
  |-- card.tsx
  |-- command.tsx
  |-- company-facts-page.tsx
  |-- input.tsx
  |-- search-form.tsx
  |-- search-input.tsx
  |-- search-results.tsx
  |-- skeleton.tsx
  |-- spinner.tsx


plus some other standard files in a Next.js project.

Always return the code in a clear manner, commented, and using best practices. If you are not returning the entire code of 
the file you need to be extremely clear where I should incorporate that code. 

Here are the files you need 

File: lib/modelConfig.ts
----------------------------------------
export type ModelConfig = {
    contextWindow: number;
    tokenSafetyMargin: number;
    maxChunkSize: number;
    reservedCompletionTokens: number;
  };
  
  export const MODEL_TOKEN_LIMITS: Record<string, ModelConfig> = {
    // DeepSeek models (adjust according to actual limits)
    'deepseek:deepseek-chat': {
      contextWindow: 32768,
      tokenSafetyMargin: 1024,
      maxChunkSize: 4000,
      reservedCompletionTokens: 8000
    },
    'deepseek:deepseek-reasoner': {
      contextWindow: 32768,
      tokenSafetyMargin: 1024,
      maxChunkSize: 4000,
      reservedCompletionTokens: 8000
    },
    // Add other models as needed
    'gpt-4': {
      contextWindow: 8192,
      tokenSafetyMargin: 512,
      maxChunkSize: 2000,
      reservedCompletionTokens: 8000
    }
  };
  
  export function getModelConfig(model: string): ModelConfig {
    const defaultConfig: ModelConfig = {
      contextWindow: 4000,
      tokenSafetyMargin: 256,
      maxChunkSize: 2000,
      reservedCompletionTokens: 800
    };
    
    return MODEL_TOKEN_LIMITS[model] || defaultConfig;
  }
----------------------------------------

File: lib/prompts.ts
----------------------------------------
// lib/prompts.ts

export const defaultSummarizationTemplate = `You are a Summarization Assistant. Your job is to read the text below—written in any language—and produce a single-paragraph summary in clear, fluent English. Focus on the following:

Key financial metrics (e.g., revenue, assets, profitability)
Risks (e.g., market risks, operational risks)
Opportunities (e.g., potential growth, strategic advantages)

Instructions:
- Write exactly one paragraph.
- Emphasize the most relevant financial details, along with notable risks and opportunities.
- Avoid minor or irrelevant information.
- Output only the summarized text, with no extra commentary, headings, or disclaimers.
- Include source file path and page numbers
- Note any ownership relationships
- Preserve exact numerical values with units

Document Text: {documentText};

Output format:
    {
      "companies": [{
        "name": "Example Corp",
        "type": "company",
        "parent": "Parent Fund",
        "variables": {
          "valuation": 1000000,
          "revenue": 500000
        },
        "sources": [{
          "filePath": "documents/financials.pdf",
          "pageNumber": 3
        }]
      }]
    }
`;


// -------------------------------------------------
// 1) UPDATED EXTRACTION TEMPLATE
// -------------------------------------------------
export const defaultExtractionTemplate = `You are an Information Extraction Assistant. Your task is to read the given text (which may appear in any language) and extract any company-level financial data into a well-structured JSON array. 
There could be multiple companies mentioned, so generate an array entry for each distinct company.

**IMPORTANT**: 
- Each variable must appear **only once**, without appending the year to the variable name. 
- If a year is mentioned in the text (e.g., 2018, 2019), store that as a nested object under the variable key. 
- Example structure for a single variable "operating_income" across 2018 and 2019:

  "variables": {
    "operating_income": {
      "2018": {
        "value": "123,456",
        "currency": "USD",
        "sources": [
          {
            "filePath": "some.pdf",
            "pageNumber": 1,
            "confidence": 0.9
          }
        ]
      },
      "2019": {
        "value": "200,000",
        "currency": "USD",
        "sources": []
      }
    }
  }

Rules:
- Output ONLY valid JSON: no markdown, no extra text.
- Use EXACT values from the text (including currency symbols) for numeric fields where possible.
- If multiple statements for different years are found, use the year as an integer key (e.g. "2018").
- If a variable is mentioned without a specific year, you may store it under "value" directly. 
- If a "type" of entity (company/fund) is mentioned, store it in the "type" field.
- If the text includes a short description of the company, store it in the "description" field.
- Omit fields not found in the text.

Document Text:
{documentText}
`;


// -------------------------------------------------
// 2) UPDATED CONSOLIDATION TEMPLATE
// -------------------------------------------------
export const defaultConsolidationTemplate = `Consolidate company data STRICTLY using this format:
{
  "companies": [{
    "name": "Consolidated Name",
    "type": "company|fund|fund-of-funds",
    "parent": "Parent Entity",
    "variables": {
      "metric_name": {
        "value": 123,
        "sources": [{
          "filePath": "document.pdf",
          "pageNumber": 5,
          "confidence": 0.95
        }],
        "2018": {
          "value": 456,
          "sources": [...]
        }
      }
    },
    "ownershipPath": ["Top Parent", "Immediate Parent"],
      "investments": [{
      "company": "Invested Company Name",
      "ownershipPercentage": 30,
      "sources": [...] 
    }],
    "subsidiaries": ["Subsidiary Name"],
    "parentFund": "Main Fund Name",
  }]
}

Rules:
1. ALWAYS return an array of companies, even if empty.
2. DO NOT append the year to the variable name; if a year is present, store it under that key inside "metric_name".
3. Consolidate repeated variables. If the same metric is found in multiple places, combine them as necessary, merging sources.
4. Convert all values to numbers where possible, but preserve numeric formatting if it's ambiguous (like "1,501,419" can stay as string if uncertain).
5. Use EXACT names from the raw data for the company and variables, except do not append the year in the variable name.
6. ALWAYS translate the variable names to English, even if the original text is in another language.
7. Always return the file path and page number for each source, this is a must, you know for sure what is the name of the file, and the page number comes from information inside of the text. 
8. For funds, list all invested companies in 'investments' array
9. For companies, list parent fund in 'parentFund' 
10. For subsidiaries, list parent company in 'parentCompany'
11. Maintain full ownership hierarchy in 'ownershipPath'

RAW DATA: {rawData}

OUTPUT:
`;

// -------------------------------------------------
// 3) VARIABLE NAME DETECTION PROMPT
// (Optional, only if you use it in your pipeline)
// -------------------------------------------------
export const defaultVariableExtraction = `Out of the following text, identify what financial variables are referenced, the text can be written in languages different than English. Return **only** the list of variables in lower case, using underscores for spaces.

Example:
["revenue", "operating_income", "total_assets"]

If a year is mentioned (like 2019), do **not** embed that year into the variable name— we only want the raw variable name. We also want:
- A one-paragraph short company description, if available
- A "type" field: "company" or "fund" (if the entity invests in other companies)

{text}
`;

// 2-A) INTERMEDIATE CONSOLIDATION TEMPLATE
export const defaultIntermediateConsolidationTemplate = `
Consolidate the following company data into valid JSON. This is an INTERMEDIATE step
per document only. DO NOT merge with data from other documents yet.

**Input** (rawData):
  {rawData}

**Rules**:
1. Return a JSON array or an object with a "companies" field that is itself an array. E.g.
   [{ "name":"...", "type":"company", "variables": {...}, "parent":"...", "ownershipPath":[] }, ...]
2. Make sure each company's variables are merged if repeated within THIS text. 
3. Use EXACT numeric or string values you see in the input (unless merging year-based). 
4. Do not combine data for other documents or references.
5. Summaries or disclaimers are not needed; just the JSON data.

**Output**:
\`\`\`json
[ ...or... { "companies": [ ... ] } ] 
\`\`\`
`.trim();
----------------------------------------

File: lib/utils.tsx
----------------------------------------
// lib/utils.ts
export function formatCIK(cik: string): string {
    return cik.padStart(10, '0');
  }

  // lib/utils.ts
export function cn(...classes: (string | undefined)[]) {
  return classes.filter(Boolean).join(" ")
}

----------------------------------------

File: app/favicon.ico
----------------------------------------
Error reading file: 'utf-8' codec can't decode byte 0x96 in position 50: invalid start byte
----------------------------------------

File: app/types.ts
----------------------------------------
// types.ts

export interface CompanySource {
  filePath: string;
  pageNumber?: number;
  extractionDate: string;
}

export type CompanyInfo = {
  name: string;
  sector?: string;
  years?: number[];
  variables?: Record<string, VariableData>;
  sources?: CompanySource[];
};

export interface VariableData {
  value?: number | string;
  currency?: string;
  unit?: string;
}

export interface ConsolidatedCompany extends CompanyInfo {
  variables: Record<string, VariableData>;
  dates: string[];
  children?: ConsolidatedCompany[];
  ownershipPath: string[];
  parent: ConsolidatedCompany | null;

  // Optional if dealing with funds
  type?: 'company' | 'fund';
  investments?: Array<{
    company: string;
    ownershipPercentage?: number;
  }>;
  subsidiaries?: string[];
}

export interface SessionSummary {
  session_id: number;
  session_name: string;
  created_at: string;
  file_count: number;
}

export interface SessionData {
  session_name: string;
  fileTree?: FileNode[];
  extractedTexts: Record<string, string>;
  summaries: Record<string, string>;
  rawResponses: Record<string, { prompt: string; response: string }>;
  consolidatedCompanies?: ConsolidatedCompany[];
}

export interface FileNode {
  name: string;
  type: 'file' | 'folder';
  children?: FileNode[];
  content?: string;
  base64Data?: string;
  fullPath?: string;
  selected?: boolean;
  highlighted?: boolean;
  localPath?: string; // Added for file storage tracking
}

export type CompanyMap = Map<string, ConsolidatedCompany>;
export type ExtractedTexts = Record<string, string>;
export type FileTree = FileNode[];

----------------------------------------

File: app/layout.tsx
----------------------------------------
// app/layout.tsx

import type { Metadata } from 'next';
import { Inter } from 'next/font/google';
import './globals.css';

// Components
import Navbar from '@/components/Navbar';
import Footer from '@/components/Footer';

const inter = Inter({ subsets: ['latin'] });

export const metadata: Metadata = {
  title: 'Alphy for PE',
  description: 'AI-powered Private Equity Analytics',
};

export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <html lang="en" suppressHydrationWarning>
      <body className={inter.className}>
        {/* Global NavBar (Client Component) */}
        
        
        {/* Page content */}
        {children}
        
        {/* Global Footer */}
        <Footer />
      </body>
    </html>
  );
}

----------------------------------------

File: app/page.tsx
----------------------------------------
// app/page.tsx
import Navbar from '@/components/Navbar';
import Link from 'next/link';
import { BarChart, CloudUpload, ShieldCheck } from 'lucide-react';
import AnalysisPreview from '@/components/AnalysisPreview';
import TestimonialsSlider from '@/components/TestimonialsSlider';
import 'slick-carousel/slick/slick.css';
import 'slick-carousel/slick/slick-theme.css';

export default function Home() {
  

  return (
    <div className="min-h-screen bg-gray-50">
    <Navbar />
      <main className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
        {/* Hero Section */}
        <div className="text-center py-20">
          <h1 className="text-5xl font-bold text-gray-900 mb-6 leading-tight">
            Transform Private Equity Analysis with <span className="text-blue-600">AI Insights</span>
          </h1>
          <p className="text-xl text-gray-600 mb-8 max-w-3xl mx-auto">
            Accelerate due diligence and uncover hidden opportunities with our AI-powered platform. Process documents 10x faster and make data-driven investment decisions.
          </p>
          <div className="flex justify-center gap-4 mb-12">
            <Link
              href="/login"
              className="bg-blue-600 text-white px-8 py-4 rounded-xl hover:bg-blue-700 transition-all transform hover:scale-105 text-lg font-semibold"
            >
              Start Free Trial
            </Link>
            <Link
              href="/demo"
              className="border-2 border-blue-600 text-blue-600 px-8 py-4 rounded-xl hover:bg-blue-50 transition-all transform hover:scale-105 text-lg font-semibold"
            >
              Book Demo
            </Link>
          </div>

          <div className="flex justify-center gap-8 text-gray-600">
            <div className="flex items-center gap-2">
              <CloudUpload className="text-blue-600" size={20} />
              <span>Secure Document Upload</span>
            </div>
            <div className="flex items-center gap-2">
              <BarChart className="text-blue-600" size={20} />
              <span>Real-time Analytics</span>
            </div>
            <div className="flex items-center gap-2">
              <ShieldCheck className="text-blue-600" size={20} />
              <span>SOC 2 Certified</span>
            </div>
          </div>
        </div>


        {/* AI Value Proposition */}
        <div className="bg-white py-16 rounded-2xl shadow-lg mb-24 text-gray-600">
          <div className="max-w-5xl mx-auto px-4">
            <h2 className="text-3xl font-bold text-center mb-12 ">Why AI in Private Equity?</h2>
            <div className="grid md:grid-cols-2 gap-12">
              <div className="space-y-6">
                <p className="text-lg text-gray-600">
                  In today's competitive landscape, AI-powered analysis is no longer optional. Our platform helps you:
                </p>
                <ul className="space-y-4">
                  <li className="flex items-center gap-3">
                    <div className="w-8 h-8 bg-blue-100 rounded-full flex items-center justify-center">
                      <span className="text-blue-600">✓</span>
                    </div>
                    Reduce due diligence time by 70%
                  </li>
                  <li className="flex items-center gap-3">
                    <div className="w-8 h-8 bg-blue-100 rounded-full flex items-center justify-center">
                      <span className="text-blue-600">✓</span>
                    </div>
                    Identify 3x more potential risks
                  </li>
                  <li className="flex items-center gap-3">
                    <div className="w-8 h-8 bg-blue-100 rounded-full flex items-center justify-center">
                      <span className="text-blue-600">✓</span>
                    </div>
                    Process 100+ document types automatically
                  </li>
                </ul>
              </div>
              <div className="bg-gradient-to-br from-blue-50 to-blue-100 rounded-xl p-8">
                <div className="aspect-video bg-white rounded-lg shadow-md overflow-hidden">
                  <AnalysisPreview />
                </div>
              </div>
            </div>
          </div>
        </div>

        {/* Pricing Section */}
        <div className="py-16">
          <h2 className="text-3xl font-bold text-center mb-12 text-gray-600">Simple, Transparent Pricing</h2>
          <div className="grid md:grid-cols-3 gap-8 max-w-6xl mx-auto">
            {/* Free Tier */}
            <div className="bg-white p-8 rounded-2xl shadow-lg border border-gray-100 hover:shadow-xl transition-shadow text-gray-600">
              <h3 className="text-2xl font-bold mb-4">Starter</h3>
              <p className="text-4xl font-bold mb-6">$0<span className="text-lg text-gray-500">/mo</span></p>
              <ul className="space-y-4 mb-8">
                <li className="flex items-center gap-2">✓ 5 document analyses/month</li>
                <li className="flex items-center gap-2">✓ Basic risk detection</li>
                <li className="flex items-center gap-2">✓ Team of up to 3 users</li>
                <li className="flex items-center gap-2">✓ Email support</li>
              </ul>
              <Link href="/signup" className="w-full block text-center bg-gray-100 text-gray-800 py-3 rounded-lg hover:bg-gray-200">
                Get Started
              </Link>
            </div>
            {/* Pro Tier */}
            <div className="bg-blue-600 p-8 rounded-2xl shadow-lg transform scale-105 relative text-gray-600">
              <div className="absolute top-0 right-0 bg-yellow-400 text-black px-4 py-1 rounded-bl-xl text-sm font-semibold">
                Most Popular
              </div>
              <h3 className="text-2xl font-bold text-white mb-4">Professional</h3>
              <p className="text-4xl font-bold text-white mb-6">$499<span className="text-lg text-blue-100">/mo</span></p>
              <ul className="space-y-4 mb-8 text-blue-50">
                <li className="flex items-center gap-2">✓ 50 document analyses/month</li>
                <li className="flex items-center gap-2">✓ Advanced AI insights</li>
                <li className="flex items-center gap-2">✓ Custom reporting</li>
                <li className="flex items-center gap-2">✓ Priority support</li>
                <li className="flex items-center gap-2">✓ Team of up to 10 users</li>
              </ul>
              <Link href="/signup" className="w-full block text-center bg-white text-blue-600 py-3 rounded-lg hover:bg-gray-100">
                Start Free Trial
              </Link>
            </div>
            {/* Enterprise Tier */}
            <div className="bg-white p-8 rounded-2xl shadow-lg border border-gray-100 hover:shadow-xl transition-shadow text-gray-600">
              <h3 className="text-2xl font-bold mb-4">Enterprise</h3>
              <p className="text-4xl font-bold mb-6">Custom</p>
              <ul className="space-y-4 mb-8">
                <li className="flex items-center gap-2">✓ Unlimited analysis</li>
                <li className="flex items-center gap-2">✓ Dedicated AI models</li>
                <li className="flex items-center gap-2">✓ SLA & 24/7 support</li>
                <li className="flex items-center gap-2">✓ Custom integrations</li>
                <li className="flex items-center gap-2">✓ On-premise options</li>
              </ul>
              <Link href="/contact" className="w-full block text-center bg-gray-800 text-white py-3 rounded-lg hover:bg-gray-700">
                Contact Sales
              </Link>
            </div>
          </div>
        </div>
         {/* Testimonials Section #!TODO not really looking nice
         <section className="my-16 container mx-auto px-4">
          <h2 className="text-3xl font-bold mb-6 text-center">What Our Customers Say</h2>
          <TestimonialsSlider />
        </section>
        */}
      </main>
    </div>
  );
}
----------------------------------------

File: app/globals.css
----------------------------------------
@tailwind base;
@tailwind components;
@tailwind utilities;

:root {
  --background: #ffffff;
  --foreground: #171717;
}

@media (prefers-color-scheme: dark) {
  :root {
    --background: #0a0a0a;
    --foreground: #ededed;
  }
}

body {
  color: var(--foreground);
  background: var(--background);
  font-family: Arial, Helvetica, sans-serif;
}

/* Bounce-in animation */
@keyframes bounceIn {
  0% {
    transform: translateY(-50px);
    opacity: 0;
  }
  100% {
    transform: translateY(0);
    opacity: 1;
  }
}

.animate-bounce-in {
  animation: bounceIn 0.5s ease-out forwards;
}

@keyframes fadeInUp {
  0% {
    opacity: 0;
    transform: translateY(20px);
  }
  100% {
    opacity: 1;
    transform: translateY(0);
  }
}

.animate-fadeInUp {
  animation: fadeInUp 0.8s ease-out;
}

----------------------------------------

File: app/settings/page.tsx
----------------------------------------
'use client';
import { useState, useEffect } from 'react';
import { useRouter } from 'next/navigation';
import Navbar from '@/components/Navbar';
import { 
  defaultSummarizationTemplate,
  defaultExtractionTemplate,
  defaultConsolidationTemplate,
  defaultVariableExtraction
} from '@/lib/prompts';

export default function SettingsPage() {
  const [user, setUser] = useState<any>(null);
  const [apiKeys, setApiKeys] = useState<Record<string, string>>({});
  const [currentPassword, setCurrentPassword] = useState('');
  const [newPassword, setNewPassword] = useState('');
  const [message, setMessage] = useState('');
  const router = useRouter();


const [summarizationTemplate, setSummarizationTemplate] = useState(defaultSummarizationTemplate);
const [extractionTemplate, setExtractionTemplate] = useState(defaultExtractionTemplate);
const [consolidationTemplate, setConsolidationTemplate] = useState(defaultConsolidationTemplate);
const [variableExtraction, setVariableExtraction] = useState(defaultVariableExtraction);


  useEffect(() => {
    const fetchUser = async () => {
      const userId = localStorage.getItem('userId');
      const email = localStorage.getItem('userEmail');
      if (!userId || !email) {
        router.push('/login');
        return;
      }
      setUser({ id: userId, email });

      // Load saved templates
      const savedSummarization = localStorage.getItem('summarizationTemplate');
      const savedExtraction = localStorage.getItem('extractionTemplate');
      const savedConsolidation = localStorage.getItem('consolidationTemplate');
      const savedVariableExtraction = localStorage.getItem('variableExtraction');
            
      if (savedSummarization) setSummarizationTemplate(savedSummarization);
      if (savedExtraction) setExtractionTemplate(savedExtraction);
      if (savedConsolidation) setConsolidationTemplate(savedConsolidation);
      if (savedVariableExtraction) setVariableExtraction(savedVariableExtraction);
      
      // Fetch API keys from your local endpoint
      try {
        const res = await fetch(`/api/api-keys?userId=${userId}`);
        const text = await res.text();
        let data = {};
        try {
          data = text ? JSON.parse(text) : {};
        } catch (error) {
          console.error("Error parsing API keys JSON: ", error);
        }
        if ((data as any).apiKeys) {
          setApiKeys(
            Object.fromEntries(
              (data as any).apiKeys.map((k: { provider: string; decrypted_key: string }) => [
                k.provider,
                k.decrypted_key
              ])
            )
          );
        }
      } catch (err) {
        console.error('Error fetching API keys:', err);
      }
    };
    fetchUser();
  }, [router]);

  const saveTemplates = async (e: React.FormEvent) => {
    e.preventDefault();
    try {
      localStorage.setItem('summarizationTemplate', summarizationTemplate);
      localStorage.setItem('extractionTemplate', extractionTemplate);
      localStorage.setItem('consolidationTemplate', consolidationTemplate);
      localStorage.setItem('variableExtraction', variableExtraction);
      setMessage('Templates saved successfully');
    } catch (err) {
      setMessage('Error saving templates');
      console.error(err);
    }
  };

  const updateProfile = async (e: React.FormEvent) => {
    e.preventDefault();
    try {
      const res = await fetch('/api/user', {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          email: user.email,
          company: user.company // if you store company info
        }),
      });
      const result = await res.json();
      if (!res.ok) throw new Error(result.error || 'Error updating profile');
      setMessage('Profile updated successfully');
    } catch (err) {
      setMessage('Error updating profile');
      console.error(err);
    }
  };

  const changePassword = async (e: React.FormEvent) => {
    e.preventDefault();
    try {
      const res = await fetch('/api/user/password', {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          currentPassword,
          newPassword,
        }),
      });
      const result = await res.json();
      if (!res.ok) throw new Error(result.error || 'Error changing password');
      setMessage('Password changed successfully');
    } catch (err) {
      setMessage('Error changing password');
      console.error(err);
    }
  };

  const saveApiKeys = async (e: React.FormEvent) => {
    e.preventDefault();
    try {
      const updates = Object.entries(apiKeys).map(([provider, key]) => ({
        user_id: user.id,
        provider,
        decrypted_key: key,
        updated_at: new Date().toISOString()
      }));

      const res = await fetch('/api/api-keys', {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ updates }),
      });
      const result = await res.json();
      if (!res.ok) throw new Error(result.error || 'Error saving API keys');
      setMessage('API keys updated successfully');
    } catch (err) {
      setMessage('Error saving API keys');
      console.error(err);
    }
  };

  return (
    <div className="min-h-screen bg-gray-50">
     <Navbar />
      <main className="max-w-2xl mx-auto px-4 py-8">
        <h1 className="text-2xl font-bold mb-6 text-gray-800">Settings</h1>

        {/* Profile Section */}
        <form onSubmit={updateProfile} className="bg-white p-6 rounded-lg shadow mb-6">
          <h2 className="text-xl font-semibold mb-4 text-gray-800">Profile</h2>
          <div className="mb-4">
            <label className="block text-sm font-medium text-gray-600 mb-1">Email</label>
            <input
              type="email"
              value={user?.email || ''}
              className="w-full p-2 border rounded text-gray-700"
              disabled
            />
          </div>
          <button type="submit" className="bg-blue-600 text-white px-4 py-2 rounded">
            Update Profile
          </button>
        </form>

        {/* Password Change */}
        <form onSubmit={changePassword} className="bg-white p-6 rounded-lg shadow mb-6">
          <h2 className="text-xl font-semibold mb-4 text-gray-800">Change Password</h2>
          <div className="mb-4">
            <label className="block text-sm font-medium text-gray-600 mb-1">Current Password</label>
            <input
              type="password"
              value={currentPassword}
              onChange={(e) => setCurrentPassword(e.target.value)}
              className="w-full p-2 border rounded text-gray-700"
            />
          </div>
          <div className="mb-4">
            <label className="block text-sm font-medium text-gray-600 mb-1">New Password</label>
            <input
              type="password"
              value={newPassword}
              onChange={(e) => setNewPassword(e.target.value)}
              className="w-full p-2 border rounded text-gray-700"
            />
          </div>
          <button type="submit" className="bg-blue-600 text-white px-4 py-2 rounded">
            Change Password
          </button>
        </form>

        {/* API Keys */}
        <form onSubmit={saveApiKeys} className="bg-white p-6 rounded-lg shadow">
          <h2 className="text-xl font-semibold mb-4 text-gray-800">API Keys</h2>
          {['openai', 'anthropic', 'cohere'].map((provider) => (
            <div key={provider} className="mb-4">
              <label className="block text-sm font-medium text-gray-600 mb-1 capitalize">
                {provider} API Key
              </label>
              <input
                type="password"
                value={apiKeys[provider] || ''}
                onChange={(e) =>
                  setApiKeys({ ...apiKeys, [provider]: e.target.value })
                }
                className="w-full p-2 border rounded text-gray-700"
              />
            </div>
          ))}
          <button type="submit" className="bg-blue-600 text-white px-4 py-2 rounded">
            Save API Keys
          </button>
        </form>

          {/* LLM Prompt Templates Section */}
        <form onSubmit={saveTemplates} className="bg-white p-6 rounded-lg shadow mt-6">
          <h2 className="text-xl font-semibold mb-4 text-gray-800">LLM Prompt Templates</h2>
          <p className="mb-2 text-gray-600">Customize the prompt templates used at each step.</p>
          
          <label className="block text-sm font-medium text-gray-600 mt-4">
            Summarization Template
          </label>
          <textarea
            className="w-full p-2 border rounded text-gray-700"
            rows={6}
            value={summarizationTemplate}
            onChange={(e) => setSummarizationTemplate(e.target.value)}
          />

          <label className="block text-sm font-medium text-gray-600 mt-4">
            Extraction Template
          </label>
          <textarea
            className="w-full p-2 border rounded text-gray-700"
            rows={8}
            value={extractionTemplate}
            onChange={(e) => setExtractionTemplate(e.target.value)}
          />

          <label className="block text-sm font-medium text-gray-600 mt-4">
            Consolidation Template
          </label>
          <textarea
            className="w-full p-2 border rounded text-gray-700"
            rows={10}
            value={consolidationTemplate}
            onChange={(e) => setConsolidationTemplate(e.target.value)}
          />

          <label className="block text-sm font-medium text-gray-600 mt-4">
            Variable Extraction Template
          </label>
          <textarea
            className="w-full p-2 border rounded text-gray-700"
            rows={6}
            value={variableExtraction}
            onChange={(e) => setVariableExtraction(e.target.value)}
          />

          <button type="submit" className="mt-4 bg-blue-600 text-white px-4 py-2 rounded">
            Save Templates
          </button>
        </form>

        {message && (
          <div className="mt-4 p-3 bg-blue-100 text-blue-800 rounded text-gray-700">
            {message}
          </div>
        )}
      </main>
    </div>
  );
}

----------------------------------------

File: app/signup/page.tsx
----------------------------------------
'use client';

import { useState } from 'react';
import { useRouter } from 'next/navigation';
import Link from 'next/link';
import Navbar from '@/components/Navbar';

export default function SignupPage() {
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [company, setCompany] = useState('');
  const [reason, setReason] = useState('');
  const [error, setError] = useState<string | null>(null);
  const [successMessage, setSuccessMessage] = useState('');
  const router = useRouter();
  const handleSignup = async (e: React.FormEvent) => {
    e.preventDefault();
    setError(null);
    setSuccessMessage('');
    
    if (!email || !password || !company || !reason) {
      setError('Please fill out all fields');
      return;
    }
  
    try {
      const response = await fetch('/api/auth/signup', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          email,
          password,
          company,
          reason
        }),
      });
  
      const data = await response.json();
  
      if (!response.ok) {
        throw new Error(data.error || 'Signup failed');
      }
  
      setSuccessMessage('Sign-up successful! Redirecting to login...');
      setTimeout(() => {
        router.push('/login');
      }, 3000);
    } catch (err) {
      console.error('Signup Error:', err);
      setError(err instanceof Error ? err.message : 'Error creating account. Please try again.');
    }
  };

  return (
    <div className="min-h-screen bg-gray-50">
      <Navbar />
      <main className="flex items-center justify-center px-4 py-12">
        <div className="w-full max-w-md bg-white rounded-lg shadow-md p-8">
          <h1 className="text-2xl font-bold text-center text-blue-600 mb-6">
            Create Your Account
          </h1>
          {successMessage && (
            <div className="mb-4 bg-green-100 border border-green-200 text-green-800 p-3 rounded-md">
              {successMessage}
            </div>
          )}
          {error && <p className="text-red-600 text-sm mb-4">{error}</p>}
          <form onSubmit={handleSignup} className="space-y-4">
            <div>
              <label className="block text-gray-700 text-sm font-medium mb-1">
                Email
              </label>
              <input
                type="email"
                className="w-full border border-gray-300 rounded-md p-2 text-gray-700"
                value={email}
                onChange={(e) => setEmail(e.target.value)}
                required
                placeholder="Enter your email"
              />
            </div>
            <div>
              <label className="block text-gray-700 text-sm font-medium mb-1">
                Password
              </label>
              <input
                type="password"
                className="w-full border border-gray-300 rounded-md p-2 text-gray-700"
                value={password}
                onChange={(e) => setPassword(e.target.value)}
                required
                placeholder="Create a password"
              />
            </div>
            <div>
              <label className="block text-gray-700 text-sm font-medium mb-1">
                Company
              </label>
              <input
                type="text"
                className="w-full border border-gray-300 rounded-md p-2 text-gray-700"
                value={company}
                onChange={(e) => setCompany(e.target.value)}
                required
                placeholder="Where do you work?"
              />
            </div>
            <div>
              <label className="block text-gray-700 text-sm font-medium mb-1">
                Reason for using the tool
              </label>
              <textarea
                className="w-full border border-gray-300 rounded-md p-2 text-gray-700"
                value={reason}
                onChange={(e) => setReason(e.target.value)}
                required
                placeholder="Briefly tell us why you want to use the tool"
              />
            </div>
            <button
              type="submit"
              className="w-full bg-blue-600 text-white py-2 rounded-md hover:bg-blue-700 transition-colors"
            >
              Sign Up
            </button>
          </form>
          <div className="mt-4 text-center text-sm text-gray-600">
            Already have an account?{' '}
            <Link href="/login" className="text-blue-600 hover:underline">
              Log In
            </Link>
          </div>
        </div>
      </main>
    </div>
  );
}

----------------------------------------

File: app/dashboard/useChat.tsx
----------------------------------------
'use client';
import { useState } from 'react';

interface ChatMessage {
  role: string;
  content: string;
}

export type ContextType = 'none' | 'local' | 'global';

export function useChat() {
  const [contextType, setContextType] = useState<ContextType>('none');
  const [chatMessage, setChatMessage] = useState('');
  const [chatHistory, setChatHistory] = useState<ChatMessage[]>([]);
  const [isChatLoading, setIsChatLoading] = useState(false);

  // Submit chat to your LLM
  const handleChatSubmit = async ({
    e,
    selectedFileText,
    globalContext,
    model
  }: {
    e: React.FormEvent<HTMLFormElement>;
    selectedFileText: string;
    globalContext: string;
    model: string;
  }) => {
    e.preventDefault();
    if (!chatMessage.trim()) return;
  
    setIsChatLoading(true);
    const newHistory = [...chatHistory, { role: 'user', content: chatMessage }];

    try {
      let context = '';
      if (contextType === 'local' && selectedFileText) {
        context = selectedFileText;
      } else if (contextType === 'global' && globalContext) {
        // Example: limit the length if needed
        context = globalContext.slice(0, 5000);
      }

      const res = await fetch('/api/llm', {
        method: 'POST',
        headers: { 
          'Content-Type': 'application/json' ,
          'x-user-id': localStorage.getItem('userId') || ''
        },
        body: JSON.stringify({ 
          prompt: chatMessage,
          context: context,
          history: newHistory,
          model: model,
          format: contextType === 'global' ? 'json' : undefined
         }),
      });

  
      const data = await res.json();
      if (!res.ok) throw new Error(data.error || 'Chat failed');
  
      setChatHistory([...newHistory, { role: 'assistant', content: data.content }]);
      setChatMessage('');
      
    } catch (error) {
      console.error('Chat Error:', error);
      setChatHistory(prev => [...prev, {
        role: 'assistant',
        content: `Error: ${(error as Error).message} - Please try again`
      }]);
    } finally {
      setIsChatLoading(false);
    }
  };

  return {
    contextType,
    setContextType,
    chatMessage,
    setChatMessage,
    chatHistory,
    setChatHistory,
    isChatLoading,
    handleChatSubmit,
  };
}

----------------------------------------

File: app/dashboard/page.tsx
----------------------------------------
'use client';

import { useRef, useState, useEffect } from 'react';
import { useRouter } from 'next/navigation';

// Components
import FileTree, { FileNode } from '@/components/FileTree';
import SelectedFilePanel from '@/components/dashboard/FilePreviewSection';
import ChatSection from '@/components/dashboard/ChatSection';
import ChatContextRadioButtons from '@/components/dashboard/RadioButtons';
import ModelSelector from '@/components/dashboard/ModelSelector';
import FileAnalysisButtons from '@/components/dashboard/FileAnalysisProgress';
import SaveModal from '@/components/dashboard/SaveSessionModal';
import LoadModal from '@/components/dashboard/LoadSessionModal';
import FileUploadArea from '@/components/dashboard/FileUploadArea'; 
import { ConsolidatedCompany } from '../types';

// Icons (optional usage)
import { InformationCircleIcon } from '@heroicons/react/24/outline';

// Types
import { SessionSummary } from '@/app/history/page';
import { run } from 'node:test';
import Navbar from '@/components/Navbar';

import { getModelConfig } from '@/lib/modelConfig';

import JSZip from 'jszip';
import { getDocument, GlobalWorkerOptions } from 'pdfjs-dist';
import * as XLSX from 'xlsx';

import { CompanyInfo } from '@/app/types';

import { defaultSummarizationTemplate, defaultExtractionTemplate, defaultConsolidationTemplate, defaultVariableExtraction} from '@/lib/prompts';

import  {estimateTokens, mergeConsolidatedCompanies, arrayBufferToBase64, base64ToArrayBuffer, FilePayload}  from '@/app/dashboard/utils/utils';
GlobalWorkerOptions.workerSrc = '/pdf.worker.mjs';
const DEVELOPMENT = process.env.NEXT_PUBLIC_LLM_DEV_MODE === 'development';

import {getConsolidationPrompt, buildFileTree, getAllFiles, processZip, processFolder, 
  toggleAllFiles, handleConsolidateCompanies, addBase64ToTree, convertTree, handleFileSelect, handleLoadClick, openSaveModal, closeSaveModal,
  handleSaveConfirm, confirmLoadSession,
  analyzeFiles, saveHeavyData, saveSession, ExistingUpload} from '@/app/dashboard/utils/utils';


export default function Dashboard() {
    // Add these state variables near other useState hooks
  const [consolidateProgress, setConsolidateProgress]               = useState(0);
  const [totalFilesToConsolidate, setTotalFilesToConsolidate]       = useState(0);
  const [currentConsolidatingFile, setCurrentConsolidatingFile]     = useState('');
  const [errorFiles, setErrorFiles]                                 = useState<string[]>([]);
  const router                                                      = useRouter();
  const formRef                                                     = useRef<HTMLFormElement | null>(null);
  const [rawResponses, setRawResponses]                             = useState<Record<string, { prompt: string; response: string }>>({});
  const [extractedCompanies, setExtractedCompanies]                 = useState<Record<string, CompanyInfo[]>>({});
  const [fileTree, setFileTree]                                     = useState<FileNode[]>([]);
  const [extractedTexts, setExtractedTexts]                         = useState<Record<string, string>>({});
  const [summaries, setSummaries]                                   = useState<Record<string, string>>({});
  const [isAnalyzing, setIsAnalyzing]                               = useState(false);
  const [processingPhase, setProcessingPhase]                       = useState<'extracting' | 'summarizing' | 'idle' | 'extracting_companies'>('idle');
  const [progress, setProgress]                                     = useState(0);
  const [totalFiles, setTotalFiles]                                 = useState(0);
  const [processedFiles, setProcessedFiles]                         = useState(0);
  const [selectedSummarizationModel, setSelectedSummarizationModel] = useState('deepseek:deepseek-chat');
  const [selectedInfoRetrievalModel, setSelectedInfoRetrievalModel] = useState('deepseek:deepseek-reasoner');
  const [runSummarization, setRunSummarization]                     = useState(true);
  const [runInfoRetrieval, setRunInfoRetrieval]                     = useState(true);
  const [currentZipName, setCurrentZipName]                         = useState<string | null>(null);
  const [highlightedFiles, setHighlightedFiles]                     = useState<Set<string>>(new Set());
  const [showExtracted, setShowExtracted]                           = useState(false);
  const [allSelected, setAllSelected]                               = useState(true);
  const [currentSessionId, setCurrentSessionId]                     = useState<string | null>(null);
  const [selectedFile, setSelectedFile]                             = useState<FileNode | null>(null);
  const [successMessage, setSuccessMessage]                         = useState('');
  const [showSaveModal, setShowSaveModal]                           = useState(false);
  const [existingUploads, setExistingUploads]                       = useState<ExistingUpload[]>([]);
  const [selectedUploadOption, setSelectedUploadOption]             = useState<'new' | 'existing'>('new');
  const [newUploadName, setNewUploadName]                           = useState('');
  const [existingUploadId, setExistingUploadId]                     = useState<number | null>(null);
  const [fetchingUploads, setFetchingUploads]                       = useState(false);
  const [showLoadModal, setShowLoadModal]                           = useState(false);
  const [availableSessions, setAvailableSessions]                   = useState<SessionSummary[]>([]);
  const [isConsolidating, setIsConsolidating]                       = useState(false);
  const [llmConsolidationDebug, setLlmConsolidationDebug]           = useState<{ prompt: string; response: string }[]>([]);
  const [showDebug, setShowDebug]                                   = useState(false);

  

  useEffect(() => {
    const userId =
      typeof window !== 'undefined' ? localStorage.getItem('userId') : null;
    const currentSessionId = localStorage.getItem('currentSessionId');
    if (!userId) {
      router.push('/login');
    } else if (currentSessionId) {
      setCurrentSessionId(currentSessionId);
    }
  }, [router]);

 
  return (
    <div className="min-h-screen bg-gray-50 relative">
      <Navbar />
      <main className="max-w-7xl mx-auto px-4 py-8">
        {/* Success Message */}
        {successMessage && (
          <div className="mb-4 bg-green-100 border border-green-200 text-green-800 p-3 rounded-md">
            {successMessage}
            {/* Ensure this closing tag matches an opening tag */}
          </div>
        )}

        {/* File Upload Area */}
        <div className="bg-white rounded-lg shadow-sm p-6 mb-6">
          <FileUploadArea
            processZip={(file) => processZip(file, setFileTree)}
            processFolder={(fileList) => processFolder(fileList, setFileTree)}
            handleLoadClick={() => handleLoadClick(setAvailableSessions, setShowLoadModal)}
            isDragActive={false}
          />
        </div>

        {/* Summarization / Info Retrieval Toggles & Model Selectors */}
        <div className="space-y-4 mb-6 text-gray-600">
          <div className="bg-white p-4 rounded-lg">
            <label className="flex items-center gap-3 mb-2">
              <input
                type="checkbox"
                checked={runSummarization}
                onChange={(e) => setRunSummarization(e.target.checked)}
                className="h-4 w-4"
              />
              <span className="font-medium">Enable Summarization</span>
            </label>
            <ModelSelector
              selectedModel={selectedSummarizationModel}
              onModelChange={setSelectedSummarizationModel}
              disabled={!runSummarization}
            />
          </div>

          <div className="bg-white p-4 rounded-lg shadow-sm">
            <label className="flex items-center gap-3 mb-2">
              <input
                type="checkbox"
                checked={runInfoRetrieval}
                onChange={(e) => setRunInfoRetrieval(e.target.checked)}
                className="h-4 w-4"
              />
              <span className="font-medium">Enable Information Retrieval</span>
            </label>
            <ModelSelector
              selectedModel={selectedInfoRetrievalModel}
              onModelChange={setSelectedInfoRetrievalModel}
              disabled={!runInfoRetrieval}
            />
          </div>
        </div>

        {/* If we have a file tree, show Analyze + Save Buttons */}
        {fileTree.length > 0 && (
          <div className="bg-white rounded-lg shadow-sm p-6 mb-6">
            <div className="mb-4 flex items-center justify-between">
              <FileAnalysisButtons
                fileTree={fileTree}
                summarizationModel={
                  runSummarization ? selectedSummarizationModel : ''
                }
                infoRetrievalModel={
                  runInfoRetrieval ? selectedInfoRetrievalModel : ''
                }
                consolidationModel={
                  runInfoRetrieval ? selectedInfoRetrievalModel : ''
                }
                runSummarization={runSummarization}
                runInfoRetrieval={runInfoRetrieval}
                analyzeFiles={async () => {
                  try {
                    // Run analysis
                    await analyzeFiles(
                      {
                        runSummarization,
                        runInfoRetrieval,
                        summarizationModel: runSummarization
                          ? selectedSummarizationModel
                          : undefined,
                        infoRetrievalModel: runInfoRetrieval
                          ? selectedInfoRetrievalModel
                          : undefined,
                      },
                      fileTree,
                      getAllFiles,
                      base64ToArrayBuffer,
                      (phase: string) => setProcessingPhase(phase as 'extracting' | 'summarizing' | 'idle' | 'extracting_companies'),
                      setIsAnalyzing,
                      setProgress,
                      setProcessedFiles,
                      setTotalFiles,
                      setExtractedTexts,
                      setSummaries,
                      setExtractedCompanies,
                      setRawResponses,
                      currentSessionId || 'temp-${Date.now()}'
                    );

                    // Auto-save session with generated name
                    const sessionName = `Analysis ${new Date().toLocaleDateString()}`;
                    const sessionId = await saveSession(
                      sessionName,
                      fileTree,
                      extractedTexts,
                      summaries,
                      extractedCompanies,
                      rawResponses,
                      setCurrentSessionId,
                      setSuccessMessage
                    );
                  } catch (error) {
                    console.error('Processing error:', error);
                    alert(
                      'Analysis failed: ' +
                        (error instanceof Error ? error.message : 'Unknown error')
                    );
                  }
                }}
                openSaveModal={() => openSaveModal(setNewUploadName, setExistingUploadId, setSelectedUploadOption, setShowSaveModal, setExistingUploads, setFetchingUploads)}
                toggleAllFiles={(state) => toggleAllFiles(state, setFileTree)}
                allSelected={allSelected}
                setAllSelected={setAllSelected}
                getAllFiles={getAllFiles}
                isAnalyzing={isAnalyzing}
                progress={progress}
                processingPhase={processingPhase}
                processedFiles={processedFiles}
                totalFiles={totalFiles}
              />
            </div>

            {/* Actual File Tree */}
            <FileTree
              nodes={fileTree}
              onSelect={(node) => handleFileSelect(node || null, setSelectedFile)}
              selectedFile={
                selectedFile
                  ? { ...selectedFile, content: selectedFile.content || '' }
                  : null
              }
              onToggleConversion={(path) => {
                const updateNodes = (nodes: FileNode[]): FileNode[] =>
                  nodes.map((n) => ({
                    ...n,
                    selected: n.fullPath === path ? !n.selected : n.selected,
                    children: n.children ? updateNodes(n.children) : undefined,
                  }));
                setFileTree((prev) => updateNodes(prev));
              }}
              onToggleHighlight={(path) => {
                const newHighlighted = new Set(highlightedFiles);
                if (newHighlighted.has(path)) {
                  newHighlighted.delete(path);
                } else {
                  newHighlighted.add(path);
                }
                setHighlightedFiles(newHighlighted);

                const updateNodes = (nodes: FileNode[]): FileNode[] =>
                  nodes.map((n) => ({
                    ...n,
                    highlighted: newHighlighted.has(n.fullPath!),
                    children: n.children ? updateNodes(n.children) : undefined,
                  }));
                setFileTree(updateNodes(fileTree));
              }}
            />
          </div>
        )}

        {/* Selected File Preview */}
        {selectedFile && (
          <SelectedFilePanel
            selectedFile={{ ...selectedFile, content: selectedFile.content || '' }}
            extractedTexts={extractedTexts}
            extractedCompanies={extractedCompanies}
            summaries={summaries}
            showExtracted={showExtracted}
            setShowExtracted={setShowExtracted}
            rawResponses={rawResponses}
          />
        )}

<div className="bg-white p-4 rounded-lg shadow-sm mb-6">
  <div className="flex items-center justify-between mb-4">
    <div>
      <button
        onClick={() => {
          if (!currentSessionId) {
            alert('Please save the session first');
            return;
          }
          setErrorFiles([]);
          handleConsolidateCompanies(
            currentSessionId,
            fileTree,
            extractedTexts,
            summaries,
            extractedCompanies,
            rawResponses,
            setIsConsolidating,
            setLlmConsolidationDebug,
            setSuccessMessage,
            mergeConsolidatedCompanies,
            selectedInfoRetrievalModel,
            router,
            (processed, total, currentFile) => {
              setConsolidateProgress(processed);
              setTotalFilesToConsolidate(total);
              setCurrentConsolidatingFile(currentFile);
            },
            (errorFile) => {
              setErrorFiles(prev => [...prev, errorFile]);
            }
          );
        }}
        disabled={isConsolidating || !currentSessionId}
        className={`px-4 py-2 rounded ${
          isConsolidating || !currentSessionId
            ? 'bg-gray-300 text-gray-500 cursor-not-allowed'
            : 'bg-blue-600 text-white hover:bg-blue-700'
        }`}
      >
        {isConsolidating ? 'Consolidating...' : 'Consolidate Companies'}
      </button>
    </div>
  </div>

  {isConsolidating && (
    <div className="mt-4">
      <div className="mb-2 flex justify-between text-sm text-gray-600">
        <span>
          Processing: {currentConsolidatingFile || 'Initializing...'}
        </span>
        <span>
          {consolidateProgress} / {totalFilesToConsolidate}
        </span>
      </div>
      <div className="w-full bg-gray-200 rounded-full h-2.5">
        <div
          className="bg-blue-600 h-2.5 rounded-full transition-all duration-300"
          style={{
            width: `${(consolidateProgress / Math.max(totalFilesToConsolidate, 1)) * 100}%`
          }}
        ></div>
      </div>

      {errorFiles.length > 0 && (
        <div className="mt-4 p-3 bg-red-50 rounded-lg">
          <h4 className="font-semibold text-red-600 mb-2">
            Errors occurred in these files:
          </h4>
          <ul className="list-disc pl-5 space-y-1">
            {errorFiles.map((file, index) => (
              <li key={index} className="text-sm text-red-500">
                {file.split('/').pop()}
              </li>
            ))}
          </ul>
        </div>
      )}
    </div>
  )}
</div>

        {/* Toggle Button for Debug Info */}
        <button
          onClick={() => setShowDebug(!showDebug)}
          className="mb-4 bg-gray-200 text-gray-800 px-3 py-1 rounded ml-2"
        >
          {showDebug ? 'Hide LLM Debug Info' : 'Show LLM Debug Info'}
        </button>

        {/* Debug Info */}
        {showDebug && (
          <div className="bg-white p-4 rounded shadow mb-6 max-h-80 overflow-y-auto text-gray-600">
            <h3 className="text-lg font-semibold mb-2">Extraction Debug Info</h3>
            {Object.entries(rawResponses).map(([filePath, debug]) => (
              <div key={filePath} className="mb-4 border-b pb-2">
                <p className="font-medium text-gray-700">File: {filePath}</p>
                <p className="text-sm text-gray-600">
                  <span className="font-semibold">Prompt:</span> {debug.prompt}
                </p>
                <p className="text-sm text-gray-600">
                  <span className="font-semibold">Response:</span> {debug.response}
                </p>
              </div>
            ))}
            {llmConsolidationDebug.length > 0 && (
              <div className="mt-4 border-t pt-2">
                <h3 className="text-lg font-semibold mb-2">
                  Consolidation Debug Info
                </h3>
                {llmConsolidationDebug.map((debug, index) => (
                  <div key={index} className="mb-4 border-b pb-2">
                    <p className="text-sm text-gray-600">
                      <span className="font-semibold">Prompt:</span> {debug.prompt}
                    </p>
                    <p className="text-sm text-gray-600">
                      <span className="font-semibold">Response:</span>{' '}
                      {debug.response}
                    </p>
                  </div>
                ))}
              </div>
            )}
          </div>
        )}

        {/* Save Modal */}
        <SaveModal
          showSaveModal={showSaveModal}
          newUploadName={newUploadName}
          setNewUploadName={setNewUploadName}
          closeSaveModal={() => closeSaveModal(setShowSaveModal)}
          handleSaveConfirm={() => handleSaveConfirm(newUploadName, (sessionName: string) => saveSession(sessionName, fileTree, extractedTexts, summaries, extractedCompanies, rawResponses, setCurrentSessionId, setSuccessMessage), setShowSaveModal)}
        />
      </main>

      {/* Load Modal (rendered outside main for simplicity) */}
      <LoadModal
        showLoadModal={showLoadModal}
        availableSessions={availableSessions}
        confirmLoadSession={(sessionId) =>
          confirmLoadSession(
            sessionId,
            setFileTree,
            setRawResponses,
            () => {}, // Placeholder for setChatHistory
            setExtractedTexts,
            setSummaries,
            setExtractedCompanies,
            setCurrentSessionId,
            router // Added the missing argument
          )
        }
        setShowLoadModal={setShowLoadModal}
      />
    </div>
  );
}

----------------------------------------

File: app/dashboard/utils/utils.tsx
----------------------------------------
// ==================================================================
// 1) Imports
// ==================================================================
'use client';
// --- External Libraries ---
import JSZip from 'jszip';
import { getDocument, GlobalWorkerOptions } from 'pdfjs-dist';
import * as XLSX from 'xlsx';
import { TextItem } from 'pdfjs-dist/types/src/display/api';
import { Dispatch, SetStateAction } from 'react';

// --- Internal (Local) Imports ---
import { CompanyInfo, ConsolidatedCompany } from '@/app/types';
import {
  defaultSummarizationTemplate,
  defaultExtractionTemplate,
  defaultConsolidationTemplate,
  defaultVariableExtraction,
  defaultIntermediateConsolidationTemplate,
} from '@/lib/prompts';
import { FileNode } from '@/components/FileTree';
import { getModelConfig } from '@/lib/modelConfig';

// ==================================================================
// 2) Types & Interfaces
// ==================================================================
export const getIntermediateConsolidationPrompt = (rawData: Record<string, any>) => {
  // If you want to allow override from localStorage, do so:
  const template =
    typeof window !== 'undefined'
      ? localStorage.getItem('intermediateConsolidationTemplate') || defaultIntermediateConsolidationTemplate
      : defaultIntermediateConsolidationTemplate;

  return template.replace('{rawData}', JSON.stringify(rawData));
};

/**
 * Represents an existing file upload in the system.
 */
export type ExistingUpload = {
  upload_id: number;
  upload_name: string;
};

/**
 * Represents a file payload used to build a file tree.
 */
export interface FilePayload {
  path: string;
  base64Data: string;
  blobUrl: string;
}

// ======================================
// Refactored retrieveInfoFromTexts
// ======================================
/**
 * Retrieves company-level info from extracted texts in chunked fashion,
 * returning the final object instead of calling setState repeatedly.
 */
async function retrieveInfoFromTextsRefactored(
  extractedTexts: Record<string, string>,
  infoRetrievalModel: string,
  logId: string // optional (for logging)
): Promise<Record<string, CompanyInfo[]>> {
  // Holds the final "filePath -> arrayOfCompanies" result
  const allExtracted: Record<string, CompanyInfo[]> = {};

  // 1) Get model config for chunking
  const modelConfig = getModelConfig(infoRetrievalModel);
  const MAX_TOKENS = modelConfig.contextWindow;

  // 2) Process each file's extracted text
  for (const [fullPath, text] of Object.entries(extractedTexts)) {
    try {
      // Grab (or fallback) to your extraction template
      const template =
        typeof window !== 'undefined'
          ? localStorage.getItem('extractionTemplate') || defaultExtractionTemplate
          : defaultExtractionTemplate;

      // We chunk the text so we can pass each chunk to LLM without exceeding tokens
      const basePrompt = template.replace('{documentText}', '');
      const baseTokens = estimateTokens(basePrompt) + modelConfig.tokenSafetyMargin;

      const chunks = splitTextIntoChunks(
        text,
        MAX_TOKENS - baseTokens - modelConfig.reservedCompletionTokens,
        modelConfig.maxChunkSize
      );

      // We'll accumulate multiple chunk results into one combined array
      let combinedCompanyData: CompanyInfo[] = [];

      // We'll track some debug text for each chunk's prompt & response
      let combinedPromptDebug = '';
      let combinedResponseDebug = '';

      // 3) LLM calls for each chunk
      for (let i = 0; i < chunks.length; i++) {
        const chunk = chunks[i];
        const chunkPrompt = template.replace('{documentText}', chunk);

        // For debugging, store the chunk prompt
        combinedPromptDebug += `\n\n[CHUNK ${i + 1} PROMPT]\n${chunkPrompt}\n`;

        // POST to /api/llm
        const res = await fetch('/api/llm', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            prompt: chunkPrompt,
            model: infoRetrievalModel,
            format: 'json',
            requestType: 'extract',
            logId // optional
          })
        });

        // If LLM call succeeded:
        if (res.ok) {
          const data = await res.json();
          const rawChunkResponse = data.content || '';
          combinedResponseDebug += `\n[CHUNK ${i + 1} RESPONSE]\n${rawChunkResponse}\n`;

          // Attempt to parse the JSON the LLM returned
          const cleaned = rawChunkResponse.replace(/```json/g, '').replace(/```/g, '').trim();
          try {
            const parsed = JSON.parse(cleaned);
            let chunkCompanies: CompanyInfo[] = [];
            if (Array.isArray(parsed)) {
              chunkCompanies = parsed;
            } else if (parsed?.companies && Array.isArray(parsed.companies)) {
              chunkCompanies = parsed.companies;
            } else {
              console.error('Invalid response structure for', fullPath, parsed);
              throw new Error('Invalid response structure from LLM');
            }

            chunkCompanies = chunkCompanies.map(company => ({
              ...company,
              variables: company.variables || {},
              sources: company.sources || []
            }));
            // Merge them with what we have so far
            combinedCompanyData = mergeConsolidatedCompanies([combinedCompanyData, chunkCompanies]);
          } catch (parseErr) {
            console.error(`Failed to parse chunk JSON for ${fullPath}:`, parseErr);
          }
        } else {
          // LLM call error
          const errText = await res.text();
          console.error(`LLM call failed for chunk ${i + 1} in ${fullPath}: ${errText}`);
          combinedResponseDebug += `\n[CHUNK ${i + 1} ERROR]\n${errText}\n`;
        }
      }

      // 4) Store final array of companies in our local result
      allExtracted[fullPath] = combinedCompanyData;

      // 5) Optionally store the chunk-level debug in a global object.
      //    (In your original code you do `setRawResponses((prev) => ...)`,
      //    but you can either return it or do a single setRawResponses outside).
      // ...
      // e.g.:
      // setRawResponses((prev) => ({
      //   ...prev,
      //   [fullPath]: {
      //     prompt: combinedPromptDebug.trim(),
      //     response: combinedResponseDebug.trim()
      //   }
      // }));

    } catch (error) {
      console.error('Error in retrieveInfoFromTexts for filePath', fullPath, error);
      // In the worst case, store an empty array
      allExtracted[fullPath] = [];
    }
  }

  // 6) Return final map: fullPath -> arrayOfCompanies
  return allExtracted;
}

// ==================================================================
// 3) Utility & Helper Functions
// ==================================================================

/**
 * Estimates the number of tokens in a given text.
 * @param text - The input text.
 * @returns Estimated number of tokens.
 */
export function estimateTokens(text: string): number {
  const wordCount = text.split(/\s+/).length;
  const charCount = text.length;
  return Math.floor(wordCount * 1.5 + charCount / 4);
}

/**
 * Performs a deep clone of a given object.
 * @param obj - Object to clone.
 * @returns A deep-cloned copy of the input.
 */
const deepClone = (obj: any) => JSON.parse(JSON.stringify(obj));

/**
 * Deep merges source object into target object (with special handling for certain keys, arrays,
 * nested objects, and newly-added fields).
 * @param target - Target object to merge into.
 * @param source - Source object to merge from.
 * @returns The merged object.
 */
const deepMerge = (target: any, source: any) => {
  Object.keys(source).forEach((key) => {
    if (key === 'investments' || key === 'subsidiaries') {
      // Merge arrays while avoiding duplicates
      target[key] = Array.from(
        new Set([
          ...(target[key] || []),
          ...(source[key] || []),
        ])
      );
    } 
    // If both target & source have a nested object at this key, merge them deeply
    else if (source[key] instanceof Object && key in target) {
      Object.assign(source[key], deepMerge(target[key], source[key]));
    } 
    // If it's a new object field in source (not in target), clone it in
    else if (source[key] instanceof Object && !(key in target)) {
      target[key] = deepClone(source[key]);
    }
    // (If it's a primitive or something else new, let the final Object.assign handle it)
  });

  // Finally, copy over any remaining properties (primitives, etc.)
  return Object.assign(target, source);
};

/**
 * Converts an ArrayBuffer to a Base64-encoded string.
 * @param buffer - The ArrayBuffer to convert.
 * @returns Base64 string.
 */
export function arrayBufferToBase64(buffer: ArrayBuffer): string {
  let binary = '';
  const bytes = new Uint8Array(buffer);
  for (let i = 0; i < bytes.length; i++) {
    binary += String.fromCharCode(bytes[i]);
  }
  return btoa(binary);
}

/**
 * Decodes a Base64-encoded string into an ArrayBuffer.
 * @param base64 - The Base64 string.
 * @returns A decoded ArrayBuffer.
 */
export function base64ToArrayBuffer(base64: string): ArrayBuffer {
  const binary = atob(base64);
  const len = binary.length;
  const buffer = new ArrayBuffer(len);
  const bytes = new Uint8Array(buffer);
  for (let i = 0; i < len; i++) {
    bytes[i] = binary.charCodeAt(i);
  }
  return buffer;
}

/**
 * Returns the consolidation prompt, either from localStorage or a default.
 * @param rawData - Data to be consolidated.
 * @returns A string prompt ready for an LLM call.
 */
export const getConsolidationPrompt = (rawData: Record<string, any>) => {
  const template =
    typeof window !== 'undefined'
      ? localStorage.getItem('consolidationTemplate') || defaultConsolidationTemplate
      : defaultConsolidationTemplate;
  return template.replace('{rawData}', JSON.stringify(rawData));
};

/**
 * Builds a file tree from an array of file payloads.
 * @param files - The array of FilePayload objects.
 * @returns A hierarchical FileNode array.
 */
export const buildFileTree = (files: FilePayload[]): FileNode[] => {
  const root: FileNode = { name: '', type: 'folder', children: [] };

  files.forEach(({ path, base64Data, blobUrl }) => {
    const parts = path.split('/');
    let current = root;
    const pathSegments: string[] = [];

    parts.forEach((part, i) => {
      if (!part) return;
      pathSegments.push(part);

      const existing = current.children?.find((n) => n.name === part);
      if (existing) {
        current = existing;
      } else {
        const isFile = i === parts.length - 1;
        const newNode: FileNode = {
          name: part,
          type: isFile ? 'file' : 'folder',
          children: isFile ? undefined : [],
          base64Data: isFile ? base64Data : undefined,
          content: isFile ? blobUrl : undefined,
          fullPath: pathSegments.join('/'),
        };
        if (!current.children) current.children = [];
        current.children.push(newNode);
        current = newNode;

        // Default to selected
        if (isFile) {
          newNode.selected = true;
        }
      }
    });
  });

  return root.children || [];
};

/**
 * Recursively collects all file nodes (type 'file') within a FileNode tree.
 * @param nodes - Array of FileNodes.
 * @returns A flat array of all file-type nodes.
 */
export const getAllFiles = (nodes: FileNode[]): FileNode[] => {
  return nodes.flatMap((node) => {
    if (node.type === 'folder' && node.children) {
      return getAllFiles(node.children);
    }
    return node.type === 'file' ? [node] : [];
  });
};

/**
 * Processes a .zip file, extracting its contents into a file tree.
 * @param file - The uploaded .zip file.
 * @param setFileTree - React state setter to store the resulting FileNode array.
 */
export const processZip = async (
  file: File,
  setFileTree: React.Dispatch<React.SetStateAction<FileNode[]>>
): Promise<void> => {
  const zip = new JSZip();
  const zipContent = await zip.loadAsync(file);

  const files = await Promise.all(
    Object.values(zipContent.files)
      .filter((entry) => !entry.dir)
      .map(async (entry) => {
        const data = await entry.async('arraybuffer');
        const base64Data = arrayBufferToBase64(data);
        const blobUrl = URL.createObjectURL(new Blob([data]));
        return {
          path: entry.name,
          base64Data,
          blobUrl,
        };
      })
  );

  setFileTree(buildFileTree(files));
};

/**
 * Processes a folder input (multiple files), converting each to a file tree representation.
 * @param fileList - The FileList (from a folder input).
 * @param setFileTree - React state setter to store the resulting FileNode array.
 */
export const processFolder = async (
  fileList: FileList,
  setFileTree: React.Dispatch<React.SetStateAction<FileNode[]>>
) => {
  const filePromises = Array.from(fileList).map((file) => {
    return new Promise<FilePayload>((resolve, reject) => {
      const reader = new FileReader();
      reader.onload = () => {
        if (reader.result && typeof reader.result !== 'string') {
          // Convert arraybuffer to base64
          const base64Data = arrayBufferToBase64(reader.result);
          const blobUrl = URL.createObjectURL(file);
          resolve({
            path: file.webkitRelativePath,
            base64Data,
            blobUrl,
          });
        } else {
          reject(new Error('Failed to read file as ArrayBuffer'));
        }
      };
      reader.onerror = (err) => reject(err);
      reader.readAsArrayBuffer(file);
    });
  });

  try {
    const files = await Promise.all(filePromises);
    setFileTree(buildFileTree(files));
  } catch (err) {
    console.error('Error reading folder files:', err);
  }
};

/**
 * Splits text into chunks to accommodate token/context window constraints.
 * @param text - The text to chunk.
 * @param maxTokens - Maximum token count for a chunk.
 * @param maxChunkSize - Maximum character length for a chunk.
 * @returns An array of text chunks.
 */
function splitTextIntoChunks(
  text: string,
  maxTokens: number,
  maxChunkSize: number
): string[] {
  const chunks: string[] = [];
  let currentChunk = '';
  let currentTokens = 0;

  // First split by large headings or sections
  const sections = text.split(/(\n\s*[A-Z][A-Z0-9 ]{10,}\n)/g);

  let buffer = '';
  sections.forEach((section, index) => {
    if (index % 2 === 1) {
      // It's a heading
      buffer += section;
    } else {
      const sectionWithHeading = buffer + section;
      buffer = '';

      // Then split by paragraphs within each section
      const paragraphs = sectionWithHeading.split('\n\n');

      paragraphs.forEach((para) => {
        const paraTokens = estimateTokens(para);

        if (paraTokens > maxTokens) {
          // Handle large paragraphs with sentence splitting
          const sentences = para.split(/[.!?]\s+/g);
          sentences.forEach((sentence) => {
            const sentenceTokens = estimateTokens(sentence);
            if (
              currentTokens + sentenceTokens > maxTokens ||
              currentChunk.length + sentence.length > maxChunkSize
            ) {
              chunks.push(currentChunk.trim());
              currentChunk = '';
              currentTokens = 0;
            }
            currentChunk += sentence + '. ';
            currentTokens += sentenceTokens;
          });
        } else {
          if (
            currentTokens + paraTokens > maxTokens ||
            currentChunk.length + para.length > maxChunkSize
          ) {
            chunks.push(currentChunk.trim());
            currentChunk = '';
            currentTokens = 0;
          }
          currentChunk += para + '\n\n';
          currentTokens += paraTokens;
        }
      });
    }
  });

  if (currentChunk.trim()) {
    chunks.push(currentChunk.trim());
  }

  return chunks;
}

/**
 * Merges an array of consolidated company objects.
 * @param companiesArray - Array of arrays of company objects.
 * @returns Merged and consolidated array of company objects.
 */
export const mergeConsolidatedCompanies = (companiesArray: any[]) => {
  const companyMap = new Map<string, any>();

  companiesArray.flat().forEach((company) => {
    if (!company?.name) return;

    const existing = companyMap.get(company.name);
    // Ensure new company has valid structure
    const cloned = deepClone(company);
    const newCompany = {
      ...cloned,
      variables: cloned.variables || {},
      sources: cloned.sources || [],
    };

    // First occurrence: simply set and move on
    if (!existing) {
      companyMap.set(company.name, newCompany);
      return;
    }

    // --- Merge Variables (with year-based support and numeric sums) ---
    Object.entries(newCompany.variables).forEach(([key, value]) => {
      // In the correction snippet, `value` might be:
      //   - a number
      //   - an object with .value
      //   - an object keyed by years
      const varValue = (value as any)?.value ?? value;
      // Ensure existing "variables[key]" is an object (so we can store year-based merges)
      existing.variables[key] = existing.variables[key] || {};

      // If varValue is an object, check if it's year-based
      if (typeof varValue === 'object') {
        Object.entries(varValue).forEach(([year, yearValue]) => {
          // Merge only if the key is a 4-digit year
          if (/^\d{4}$/.test(year)) {
            existing.variables[key][year] = mergeValues(
              existing.variables[key][year],
              yearValue
            );
          }
        });
      } else {
        // Otherwise, treat it as a top-level numeric or single value
        existing.variables[key].value = mergeValues(
          existing.variables[key]?.value,
          varValue
        );
      }
    });

    // --- Merge Sources ---
    existing.sources = [...(existing.sources || []), ...(newCompany.sources || [])];

    // --- Merge Dates (with proper date-sorting) ---
    existing.dates = Array.from(
      new Set([...(existing.dates || []), ...(newCompany.dates || [])])
    ).sort((a, b) => new Date(a).getTime() - new Date(b).getTime());

    // --- Merge lastUpdated ---
    existing.lastUpdated = [existing.lastUpdated, newCompany.lastUpdated]
      .filter(Boolean)
      .sort()
      .pop();

    // Re-store in the Map
    companyMap.set(company.name, existing);
  });

  return Array.from(companyMap.values());
};

// ---------------------------------------------------
// Helper function to merge values safely
// (Sums numeric values, otherwise uses the newest
// non-undefined value)
const mergeValues = (existingVal: any, newVal: any) => {
  if (typeof existingVal === 'number' && typeof newVal === 'number') {
    return existingVal + newVal;
  }
  if (newVal !== undefined && newVal !== null) {
    return newVal;
  }
  return existingVal;
};

// ==================================================================
// 4) Analyze Flow Helpers (Extract Text, Summarize, Info Retrieval)
// ==================================================================

/**
 * Extracts text from an array of selected files (PDF/Excel only).
 */
async function extractTextsFromFiles(
  allFiles: FileNode[],
  base64ToArrayBufferFn: (b64: string) => ArrayBuffer,
  setProgress: (value: number) => void,
  setProcessedFiles: (count: number) => void,
  setProcessingPhase: (phase: string) => void
) {
  setProcessingPhase('extracting');

  const total = allFiles.length;
  let processedCount = 0;

  const newExtractedTexts: Record<string, string> = {};

  for (const node of allFiles) {
    let extracted = '';

    // Skip if no data
    if (!node.base64Data) {
      continue;
    }

    // Convert base64 -> ArrayBuffer
    const arrayBuffer = base64ToArrayBufferFn(node.base64Data);

    // Handle PDF
    if (node.name.toLowerCase().endsWith('.pdf')) {
      try {
        const data = new Uint8Array(arrayBuffer);
        const pdf = await getDocument({ data }).promise;
        let text = '';

        for (let i = 1; i <= pdf.numPages; i++) {
          const page = await pdf.getPage(i);
          const content = await page.getTextContent();
          const pageText = content.items
            .filter((item): item is TextItem => 'str' in item)
            .map((item) => item.str)
            .join(' ');
          text += `[PAGE_START:${i} fileName:${node.name}]${pageText}[PAGE_END:${i}]\n`;
        }

        extracted = text;
      } catch (err) {
        console.error(`Failed to extract text from ${node.name}`, err);
        extracted = '[Error extracting PDF text]';
      }
    }
    // Handle Excel
    else if (node.name.toLowerCase().match(/\.(xlsx|xls)$/)) {
      try {
        const workbook = XLSX.read(new Uint8Array(arrayBuffer), { type: 'array' });
        let excelText = '';
        workbook.SheetNames.forEach((sheetName) => {
          const worksheet = workbook.Sheets[sheetName];
          const sheetAsJson = XLSX.utils.sheet_to_json(worksheet, { header: 1 });
          (sheetAsJson as (string | number | boolean | null)[][]).forEach((row) => {
            excelText += row.join(' ') + '\n';
          });
          excelText += '\n';
        });
        extracted = excelText;
      } catch (err) {
        console.error(`Failed to extract text from ${node.name}`, err);
        extracted = '[Error extracting Excel text]';
      }
    } else {
      // Unsupported file type
      extracted = '[Text extraction not available for this file type]';
    }

    // Clean up extracted text
    newExtractedTexts[node.fullPath!] = extracted.trim().replace(/\s+/g, ' ');

    // Update progress
    processedCount++;
    setProcessedFiles(processedCount);
    setProgress(Math.round((processedCount / total) * 100));
  }

  return newExtractedTexts;
}

/**
 * Summarizes extracted texts using chunk-based prompts.
 */
async function summarizeExtractedTexts(
  extractedTexts: Record<string, string>,
  summarizationModel: string,
  setProcessingPhase: (phase: string) => void,
  setProgress: (value: number) => void,
  setProcessedFiles: (count: number) => void,
  setSummaries: (summaries: Record<string, string>) => void,
  logId: string,
) {
  setProcessingPhase('summarizing');
  setProgress(0);
  setProcessedFiles(0);

  const newSummaries: Record<string, string> = {};
  const total = Object.keys(extractedTexts).length;
  let count = 0;

  // Example: get your model config
  const modelConfig = getModelConfig(summarizationModel);

  for (const [fullPath, text] of Object.entries(extractedTexts)) {
    try {
      // Grab template from localStorage (or fallback)
      const template =
        typeof window !== 'undefined'
          ? localStorage.getItem('summarizationTemplate') || defaultSummarizationTemplate
          : defaultSummarizationTemplate;

      // Setup chunking
      const basePrompt = template.replace('{documentText}', '');
      const baseTokens = estimateTokens(basePrompt) + modelConfig.tokenSafetyMargin;
      const chunks = splitTextIntoChunks(
        text,
        modelConfig.contextWindow - baseTokens - 8000,
        modelConfig.maxChunkSize
      );

      let fullSummary = '';
      // Summarize each chunk
      for (const chunk of chunks) {
        const chunkPrompt = template.replace('{documentText}', chunk);

        // Example API call
        const res = await fetch('/api/llm', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            prompt: chunkPrompt,
            model: summarizationModel,
            requestType: 'summarize',
            logId: logId, // Pass the logId for tracking
          })
        });

        if (res.ok) {
          const data = await res.json();
          fullSummary += data.content + '\n\n';
        } else {
          fullSummary += ' [Chunk Summarization Failed] ';
        }
      }

      // Consolidate chunks if needed
      if (chunks.length > 1) {
        const consolidationPrompt = `Please consolidate these partial summaries into one coherent summary:\n\n${fullSummary}`;
        const res = await fetch('/api/llm', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            prompt: consolidationPrompt,
            model: summarizationModel,
            requestType: 'summarize'
          })
        });
        if (res.ok) {
          const data = await res.json();
          fullSummary = data.content;
        }
      }

      newSummaries[fullPath] = fullSummary.trim();
    } catch (error: any) {
      newSummaries[fullPath] = `Summary failed: ${(error as Error).message}`;
    }

    count++;
    setProcessedFiles(count);
    setProgress(Math.round((count / total) * 100));
  }

  setSummaries(newSummaries);
}

/**
 * Retrieves company-level info from extracted texts (chunk-based).
 */
async function retrieveInfoFromTexts(
  extractedTexts: Record<string, string>,
  infoRetrievalModel: string,
  setProcessingPhase: (phase: string) => void,
  setProgress: (value: number) => void,
  setProcessedFiles: (count: number) => void,
  setExtractedCompanies: React.Dispatch<React.SetStateAction<Record<string, CompanyInfo[]>>>,
  setRawResponses: React.Dispatch<
    React.SetStateAction<Record<string, { prompt: string; response: string }>>
  >,
  logId: string,
) {
  setProcessingPhase('extracting_companies');
  setProgress(0);
  setProcessedFiles(0);

  const total = Object.keys(extractedTexts).length;
  let count = 0;

  const modelConfig = getModelConfig(infoRetrievalModel);

  for (const [fullPath, text] of Object.entries(extractedTexts)) {
    try {
      const template =
        typeof window !== 'undefined'
          ? localStorage.getItem('extractionTemplate') || defaultExtractionTemplate
          : defaultExtractionTemplate;

      const basePrompt = template.replace('{documentText}', '');
      const baseTokens = estimateTokens(basePrompt) + modelConfig.tokenSafetyMargin;

      const chunks = splitTextIntoChunks(
        text,
        modelConfig.contextWindow - baseTokens - 8000,
        modelConfig.maxChunkSize
      );

      let allCompanies: CompanyInfo[] = [];
      let combinedPromptDebug = '';
      let combinedResponseDebug = '';

      for (let i = 0; i < chunks.length; i++) {
        const chunk = chunks[i];
        const chunkPrompt = template.replace('{documentText}', chunk);
        combinedPromptDebug += `\n\n[CHUNK ${i + 1} PROMPT]\n${chunkPrompt}\n`;
        const res = await fetch('/api/llm', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            prompt: chunkPrompt,
            model: infoRetrievalModel,
            format: 'json',
            requestType: 'extract',
            logId: logId, // Pass the logId for tracking
          })
        });
        let chunkResponse = '';
        if (res.ok) {
          const data = await res.json();
          chunkResponse = data.content || '';
          // Append chunk response text to the debug
          combinedResponseDebug += `\n[CHUNK ${i + 1} RESPONSE]\n${chunkResponse}\n`;
          // Attempt to parse as JSON
          const cleaned = chunkResponse.replace(/```json/g, '').replace(/```/g, '').trim();
          try {
            const parsed = JSON.parse(cleaned);
            let companies = Array.isArray(parsed) ? parsed : parsed?.companies || [];
            // Map 'company_name' to 'name' if present
            companies = companies.map((company: any) => ({
              ...company,
              name: company.company_name || company.name
            }));
            allCompanies = mergeConsolidatedCompanies([allCompanies, companies]);
          } catch (parseErr) {
            console.error(`Failed to parse chunk companies for ${fullPath}:`, parseErr);
          }
        } else {
          const errText = await res.text();
          console.error(`LLM call failed for chunk ${i + 1}: ${errText}`);
          combinedResponseDebug += `\n[CHUNK ${i + 1} ERROR]\n${errText}\n`;
        }
      }

      // Finally store results for this file
      setExtractedCompanies((prev) => ({
        ...prev,
        [fullPath]: allCompanies
      }));

      setRawResponses((prev) => ({
        ...prev,
        [fullPath]: {
          prompt: combinedPromptDebug.trim(),
          response: combinedResponseDebug.trim()
        }
      }));

    } catch (error) {
      console.error(`Error processing ${fullPath}:`, error);
    }

    count++;
    setProcessedFiles(count);
    setProgress(Math.round((count / total) * 100));
  }
}

// ==================================================================
// 5) Main Analysis Function
// ==================================================================

/**
 * Main function to analyze selected files (text extraction, summarization, info retrieval).
 */
export async function analyzeFiles(
  options: {
    runSummarization: boolean;
    runInfoRetrieval: boolean;
    summarizationModel?: string;
    infoRetrievalModel?: string;
  },
  fileTree: FileNode[],
  getAllFilesFn: (nodes: FileNode[]) => FileNode[],
  base64ToArrayBufferFn: (b64: string) => ArrayBuffer,
  setProcessingPhase: (phase: string) => void,
  setIsAnalyzing: (val: boolean) => void,
  setProgress: (val: number) => void,
  setProcessedFiles: (val: number) => void,
  setTotalFiles: (val: number) => void,
  setExtractedTexts: (val: Record<string, string>) => void,
  setSummaries: (val: Record<string, string>) => void,
  setExtractedCompanies: React.Dispatch<React.SetStateAction<Record<string, CompanyInfo[]>>>,
  setRawResponses: React.Dispatch<
    React.SetStateAction<Record<string, { prompt: string; response: string }>>
  >,
  logId:string,
) {
  try {
    setIsAnalyzing(true);
    setProgress(0);
    setProcessedFiles(0);

    const allFiles = getAllFilesFn(fileTree).filter((f) => f.selected);
    setTotalFiles(allFiles.length);

    // 1) EXTRACT TEXT
    const newExtractedTexts = await extractTextsFromFiles(
      allFiles,
      base64ToArrayBufferFn,
      setProgress,
      setProcessedFiles,
      setProcessingPhase
    );
    setExtractedTexts(newExtractedTexts);

    // 2) SUMMARIZE (optional)
    if (options.runSummarization && options.summarizationModel) {
      await summarizeExtractedTexts(
        newExtractedTexts,
        options.summarizationModel,
        setProcessingPhase,
        setProgress,
        setProcessedFiles,
        setSummaries,
        logId
      );
    }

    // 3) INFO RETRIEVAL (optional)
    if (options.runInfoRetrieval && options.infoRetrievalModel) {
      await retrieveInfoFromTexts(
        newExtractedTexts,
        options.infoRetrievalModel,
        setProcessingPhase,
        setProgress,
        setProcessedFiles,
        setExtractedCompanies,
        setRawResponses,
        logId
      );
    }

    let finalExtractedCompanies: Record<string, CompanyInfo[]> = {};
    if (options.runInfoRetrieval && options.infoRetrievalModel) {
      // <--- Use the updated function that returns a local result
      finalExtractedCompanies = await retrieveInfoFromTextsRefactored(
        newExtractedTexts,
        options.infoRetrievalModel,
        logId
      );
      // Now do a single setState:
      setExtractedCompanies(finalExtractedCompanies);
    }

  } catch (error) {
    console.error('Processing error:', error);
  } finally {
    setIsAnalyzing(false);
    setProcessingPhase('idle');
  }
}

export const handleConsolidateCompanies = async (
  sessionId: string,
  fileTree: FileNode[],
  extractedTexts: Record<string, string>,
  summaries: Record<string, string>,
  extractedCompanies: Record<string, CompanyInfo[]>,
  rawResponses: Record<string, { prompt: string; response: string }>,
  setIsConsolidating: Dispatch<SetStateAction<boolean>>,
  setLlmConsolidationDebug: Dispatch<SetStateAction<{ prompt: string; response: string }[]>>,
  setSuccessMessage: Dispatch<SetStateAction<string>>,
  mergeCompaniesFn: (companiesArray: any[]) => any[],
  infoRetrievalModel: string,
  router: any,
  onProgress?: (processed: number, total: number, currentFile: string) => void,
  onError?: (filePath: string) => void,
): Promise<void> => {
  setIsConsolidating(true);

  try {
    const allFilePaths = Object.keys(extractedCompanies);
    const total = allFilePaths.length;
    let processed = 0;
    if (allFilePaths.length === 0) {
      throw new Error('No companies extracted - cannot consolidate empty data');
    }

    // Prepare to log each LLM call (prompt + response):
    const consolidationDebug: Array<{ prompt: string; response: string }> = [];

    //-------------------------------------------------------------------
    // 1) PER-FILE CONSOLIDATION
    //-------------------------------------------------------------------
    // We'll gather each file's consolidated results in an array of arrays
    const perFileConsolidations: CompanyInfo[][] = [];
    // Initialize progress
    onProgress?.(0, total, '');
    for (const filePath of allFilePaths) {
      try {
        const companiesForFile = extractedCompanies[filePath] || [];
        if (!companiesForFile.length) {
          perFileConsolidations.push([]); // nothing to consolidate
          continue;
        }

        // Build the LLM prompt for just this file’s companies
        const filePrompt = getIntermediateConsolidationPrompt({ companies: companiesForFile });

        // Try calling the LLM
        const res = await fetch('/api/llm', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            prompt: filePrompt,
            model: infoRetrievalModel,
            format: 'json',
            requestType: 'consolidation',
            logId: sessionId, // for logging
          }),
        });

        if (!res.ok) {
          const details = await res.text();
          throw new Error(`Consolidation failed (file-level) for ${filePath}: ${details}`);
        }

        const { content } = await res.json();
        const cleaned = content.replace(/```json/gi, '').replace(/```/g, '').trim();

        let fileConsolidated: CompanyInfo[] = [];
        try {
          const parsed = JSON.parse(cleaned);
          if (parsed && Array.isArray(parsed.companies)) {
            fileConsolidated = parsed.companies;
          } else if (Array.isArray(parsed)) {
            fileConsolidated = parsed;
          }
        } catch (parseErr) {
          console.error(`File-level parse error [${filePath}]:`, parseErr);
        }

        // Save debug info
        consolidationDebug.push({
          prompt: filePrompt,
          response: content,
        });

        // Store the (already consolidated) array
        perFileConsolidations.push(fileConsolidated);

      } catch (error) {
        console.error(`Error processing ${filePath}:`, error);
        onError?.(filePath);
      }

      processed++;
      onProgress?.(processed, total, filePath);
    }

    //-------------------------------------------------------------------
    // 2) GLOBAL CONSOLIDATION (all files combined in chunk(s))
    //-------------------------------------------------------------------
    // Flatten all per-file consolidated data
    onProgress?.(total, total, 'Final global consolidation...');
    const allCompaniesCombined: CompanyInfo[] = perFileConsolidations.flat();
    if (allCompaniesCombined.length === 0) {
      throw new Error('No consolidated data produced at file-level. Stopping.');
    }

    // Use chunking to avoid token limit issues
    const modelConfig = getModelConfig(infoRetrievalModel);
    const maxTokens = modelConfig.contextWindow;
    const basePrompt = getConsolidationPrompt([]);
    const baseTokens = estimateTokens(basePrompt) + modelConfig.tokenSafetyMargin;
    const availableTokens = maxTokens - baseTokens - modelConfig.reservedCompletionTokens;

    // Break final data into manageable chunks
    const finalChunks: CompanyInfo[][] = [];
    let currentChunk: CompanyInfo[] = [];
    let currentTokenCount = 0;

    for (const c of allCompaniesCombined) {
      const cText = JSON.stringify(c);
      const cTokens = estimateTokens(cText);

      // If single item is oversize, skip or handle separately
      if (cTokens > availableTokens) {
        console.warn(`Skipping oversize company: ${c.name}`);
        continue;
      }

      // If adding c would exceed the chunk limit, push current chunk & start new
      if (currentTokenCount + cTokens > availableTokens) {
        finalChunks.push(currentChunk);
        currentChunk = [];
        currentTokenCount = 0;
      }
      currentChunk.push(c);
      currentTokenCount += cTokens;
    }

    if (currentChunk.length > 0) {
      finalChunks.push(currentChunk);
    }

    // We'll accumulate the final globally consolidated array here
    // and treat it as ConsolidatedCompany[] after merging
    let finalConsolidated: ConsolidatedCompany[] = [];

    // Helper to call the LLM for each chunk
    async function consolidateChunk(companiesChunk: CompanyInfo[]): Promise<CompanyInfo[]> {
      const chunkPrompt = getConsolidationPrompt({ companies: companiesChunk });
      const res = await fetch('/api/llm', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          prompt: chunkPrompt,
          model: infoRetrievalModel,
          format: 'json',
          requestType: 'consolidation',
          logId: sessionId,
        }),
      });

      if (!res.ok) {
        const details = await res.text();
        throw new Error(`Global chunk consolidation error: ${details}`);
      }

      const { content } = await res.json();
      const cleaned = content.replace(/```json/gi, '').replace(/```/g, '').trim();

      let chunkResult: CompanyInfo[] = [];
      try {
        const parsed = JSON.parse(cleaned);
        if (parsed && Array.isArray(parsed.companies)) {
          chunkResult = parsed.companies;
        } else if (Array.isArray(parsed)) {
          chunkResult = parsed;
        }
      } catch (parseErr) {
        console.error('Global-level parse error:', parseErr);
      }

      // Log debug
      consolidationDebug.push({
        prompt: chunkPrompt,
        response: content,
      });

      return chunkResult;
    }

    // Consolidate each chunk individually, merging into finalConsolidated
    for (const chunk of finalChunks) {
      const chunkRes = await consolidateChunk(chunk);
      // mergeCompaniesFn returns an array of "any", so we safely cast it
      const merged = mergeCompaniesFn([finalConsolidated, chunkRes]) as ConsolidatedCompany[];
      finalConsolidated = merged;
    }

    // 3) Save final to heavyData
    // Ensure each item has defaults for the ConsolidatedCompany properties
    await saveHeavyData(sessionId, {
      fileTree,
      extractedTexts,
      summaries,
      extractedCompanies,
      rawResponses,
      consolidatedCompanies: finalConsolidated.map(company => ({
        ...company,
        dates: company.dates || [],
        ownershipPath: company.ownershipPath || [],
        parent: company.parent || null,
        variables: company.variables || {},
      })),
    });

    // 4) Store debug logs
    setLlmConsolidationDebug(consolidationDebug);

    // 5) Navigate to /companies
    router.push(`/companies?sessionId=${sessionId}`);
  } catch (error) {
    console.error('Error (two-step consolidation):', error);
    // If something fails, we show a fallback
    router.push(`/companies?sessionId=${sessionId}&message=noData`);
  } finally {
    setIsConsolidating(false);
  }
};

// ==================================================================
// 6) Additional Utilities
// ==================================================================

export function addBase64ToTree(nodes: FileNode[]): FileNode[] {
  return nodes.map((node) => {
    if (node.type === 'folder' && node.children) {
      return { ...node, children: addBase64ToTree(node.children) };
    }
    if (node.type === 'file' && node.rawData) {
      const uint8 = new Uint8Array(node.rawData);
      let binary = '';
      for (let i = 0; i < uint8.length; i++) {
        binary += String.fromCharCode(uint8[i]);
      }
      const base64Data = btoa(binary);
      return { ...node, base64Data };
    }
    return node;
  });
}

export function convertTree(nodes: FileNode[], sessionId: number | string): FileNode[] {
  return nodes.map((node) => {
    if (node.type === 'folder' && node.children) {
      return { ...node, children: convertTree(node.children, sessionId) };
    }
    if (node.type === 'file') {
      // Convert base64 => rawData if present
      if (node.base64Data) {
        const binaryString = atob(node.base64Data);
        const bytes = new Uint8Array(binaryString.length);
        for (let i = 0; i < binaryString.length; i++) {
          bytes[i] = binaryString.charCodeAt(i);
        }
        node.rawData = bytes.buffer;
        node.base64Data = undefined; // free it up
      }
      // Build the inline content path if localPath is present
      if (node.localPath) {
        node.content = `/api/session-file?sessionId=${sessionId}&filePath=${encodeURIComponent(
          node.localPath || ''
        )}`;
      }
    }
    return node;
  });
}

/**
 * Toggles selection (selected/unselected) for all files in the file tree.
 */
export const toggleAllFiles = (
  selected: boolean,
  setFileTree: React.Dispatch<React.SetStateAction<FileNode[]>>
) => {
  const updateNodes = (nodes: FileNode[]): FileNode[] =>
    nodes.map((n) => ({
      ...n,
      selected: n.type === 'file' ? selected : n.selected,
      children: n.children ? updateNodes(n.children) : undefined
    }));
  setFileTree((prev) => updateNodes(prev));
};

/**
 * Saves heavy data (file tree, extracted texts, etc.) to the server for a given session.
 */
export const saveHeavyData = async (
  sessionId: string,
  heavyData: {
    fileTree: FileNode[];
    extractedTexts: Record<string, string>;
    summaries: Record<string, string>;
    extractedCompanies: Record<string, CompanyInfo[]>;
    rawResponses: Record<string, { prompt: string; response: string }>;
    consolidatedCompanies?: ConsolidatedCompany[];
  }
) => {
  try {
    await fetch('/api/store-heavy-data', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        sessionId,
        heavyData: {
          ...heavyData,
          consolidatedCompanies: heavyData.consolidatedCompanies || []
        }
      })
    });
  } catch (error) {
    console.error(error);
    throw error;
  }
};

export function handleFileSelect(
  node: FileNode | null,
  setSelectedFile: React.Dispatch<React.SetStateAction<FileNode | null>>
) {
  setSelectedFile(node);
}

export const openSaveModal = async (
  setNewUploadName: React.Dispatch<React.SetStateAction<string>>,
  setExistingUploadId: React.Dispatch<React.SetStateAction<number | null>>,
  setSelectedUploadOption: React.Dispatch<React.SetStateAction<'new' | 'existing'>>,
  setShowSaveModal: React.Dispatch<React.SetStateAction<boolean>>,
  setExistingUploads: React.Dispatch<React.SetStateAction<ExistingUpload[]>>,
  setFetchingUploads: React.Dispatch<React.SetStateAction<boolean>>,
): Promise<void> => {
  setNewUploadName('');
  setExistingUploadId(null);
  setSelectedUploadOption('new');
  try {
    setFetchingUploads(true);
    const res = await fetch('/api/uploads', {
      headers: { 'x-user-id': localStorage.getItem('userId') || '' },
    });
    if (!res.ok) throw new Error('Failed to fetch existing uploads');
    const data = await res.json();
    setExistingUploads(data.uploads || []);
  } catch (err) {
    console.error('Error fetching uploads:', err);
    setExistingUploads([]);
  } finally {
    setFetchingUploads(false);
    setShowSaveModal(true);
  }
};

export const closeSaveModal = (
  setShowSaveModal: React.Dispatch<React.SetStateAction<boolean>>,
) => {
  setShowSaveModal(false);
};

export const handleSaveConfirm = async (
  newUploadName: string,
  saveSession: (sessionName: string) => Promise<string>,
  setShowSaveModal: React.Dispatch<React.SetStateAction<boolean>>,
) => {
  try {
    // Get the session name from your state (you'll need to ensure this is populated)
    const sessionName =
      newUploadName.trim() || `Session ${new Date().toLocaleDateString()}`;
    const sessionId = await saveSession(sessionName);
    localStorage.setItem('currentSessionId', sessionId);
    setShowSaveModal(false);
  } catch (error) {
    console.error('Error in handleSaveConfirm:', error);
    alert('Error saving data: ' + (error as Error).message);
  }
};

export async function saveSession(
  sessionName: string,
  fileTree: FileNode[],
  extractedTexts: Record<string, string>,
  summaries: Record<string, string>,
  extractedCompanies: Record<string, CompanyInfo[]>,
  rawResponses: Record<string, { prompt: string; response: string }>,
  setCurrentSessionId: React.Dispatch<React.SetStateAction<string | null>>,
  setSuccessMessage: React.Dispatch<React.SetStateAction<string>>
): Promise<string> {
  const fileTreeWithBase64 = addBase64ToTree(fileTree);
  const res = await fetch('/api/sessions', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'x-user-id': localStorage.getItem('userId') || '',
    },
    body: JSON.stringify({ sessionName }),
  });
  if (!res.ok) throw new Error('Failed to save session');
  const data = await res.json();
  setCurrentSessionId(data.session_id);
  await saveHeavyData(data.session_id, {
    fileTree: fileTreeWithBase64,
    extractedTexts,
    summaries,
    extractedCompanies,
    rawResponses,
  });

  setCurrentSessionId(data.session_id);
  setSuccessMessage('Session saved successfully!');
  localStorage.setItem('currentSessionId', data.session_id); // Store in local storage
  return data.session_id;
}

export const handleLoadClick = async (
  setAvailableSessions: React.Dispatch<React.SetStateAction<any[]>>,
  setShowLoadModal: React.Dispatch<React.SetStateAction<boolean>>
) => {
  try {
    const res = await fetch('/api/sessions', {
      headers: { 'x-user-id': localStorage.getItem('userId') || '' },
    });
    const data = await res.json();
    setAvailableSessions(data.sessions);
    setShowLoadModal(true);
  } catch {
    alert('Error loading sessions');
  }
};

export const confirmLoadSession = async (
  sessionId: string,
  setFileTree: Dispatch<SetStateAction<FileNode[]>>,
  setRawResponses: Dispatch<SetStateAction<Record<string, { prompt: string; response: string }>>>,
  setChatHistory: Dispatch<SetStateAction<string | null>>,
  setExtractedTexts: Dispatch<SetStateAction<Record<string, string>>>,
  setSummaries: Dispatch<SetStateAction<Record<string, string>>>,
  setExtractedCompanies: Dispatch<SetStateAction<Record<string, CompanyInfo[]>>>,
  setCurrentSessionId: Dispatch<SetStateAction<string | null>>,
  router: any
) => {
  try {
    const userId = localStorage.getItem('userId');
    if (!userId) {
      router.push('/login');
      return;
    }

    // 1) Confirm the session is available
    const response = await fetch('/api/sessions', {
      headers: { 'x-user-id': userId },
    });
    if (!response.ok) throw new Error('Failed to load session');
    const data = await response.json();
    if (!data.sessions || data.sessions.length === 0) {
      alert('No session data found.');
      return;
    }

    // 2) Fetch heavy data
    const heavyRes = await fetch(`/api/store-heavy-data?sessionId=${sessionId}`);
    if (!heavyRes.ok) throw new Error('Failed to load heavy data');
    const heavyData = await heavyRes.json();

    setRawResponses(heavyData.rawResponses || {});

    // 3) Rebuild the fileTree from base64
    const rebuiltTree = convertTree(heavyData.fileTree || [], sessionId);
    setFileTree(rebuiltTree);

    // 4) Restore chat history, extracted texts, summaries
    setChatHistory(heavyData.chatHistory || []);
    setExtractedTexts(heavyData.extractedTexts || {});
    setSummaries(heavyData.summaries || {});
    localStorage.setItem('currentSessionId', sessionId);
    setCurrentSessionId(sessionId);
    router.push(`/dashboard?sessionId=${sessionId}`); // Redirect to dashboard
  } catch (error) {
    console.error('Error loading session:', error);
    alert('Error loading session: ' + (error as Error).message);
  }
};

----------------------------------------

File: app/history/page.tsx
----------------------------------------
'use client';

import { useEffect, useState } from 'react';
import { useRouter } from 'next/navigation';
import { TrashIcon } from '@heroicons/react/24/outline';
import Navbar from '@/components/Navbar';

export interface SessionSummary {
  session_id: number;
  session_name: string;
  created_at: string;
  file_count: number;
}

export default function HistoryPage() {
  const router = useRouter();
  const [sessions, setSessions] = useState<SessionSummary[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState('');

  // For custom "internal" delete confirmation
  const [showDeleteModal, setShowDeleteModal] = useState(false);
  const [selectedSession, setSelectedSession] = useState<SessionSummary | null>(null);

  // Fetch user sessions on mount
  useEffect(() => {
    const userId = localStorage.getItem('userId');
    if (!userId) {
      // Not logged in
      router.push('/login');
      return;
    }

    fetch('/api/sessions', {
      headers: { 'x-user-id': userId }
    })
      .then((res) => res.json())
      .then((data) => {
        if (data.error) {
          setError(data.error);
          return;
        }
        setSessions(data.sessions || []);
      })
      .catch((err) => {
        setError(err.message || 'Error fetching sessions');
      })
      .finally(() => {
        setLoading(false);
      });
  }, [router]);

  // Delete a session

  function handleOpenDeleteModal(session: SessionSummary) {
    setSelectedSession(session);
    setShowDeleteModal(true);
  }

  function handleCloseDeleteModal() {
    setShowDeleteModal(false);
    setSelectedSession(null);
  }
   // Actual deletion logic, only called upon modal confirmation
   async function handleConfirmDelete() {
    if (!selectedSession) return; // safety check

    try {
      const userId = localStorage.getItem('userId') || '';
      const res = await fetch(`/api/sessions/${selectedSession.session_id}`, {
        method: 'DELETE',
        headers: { 'x-user-id': userId }
      });

      if (!res.ok) {
        const d = await res.json();
        throw new Error(d.error || 'Failed to delete session');
      }

      // Remove it from local state
      setSessions((prev) =>
        prev.filter((s) => s.session_id !== selectedSession.session_id)
      );
    } catch (err: unknown) {
      console.error(err);
      if (err instanceof Error) {
        alert('Error deleting session: ' + err.message);
      } else {
        alert('Unknown error deleting session.');
      }
    } finally {
      handleCloseDeleteModal();
    }
  }

  if (loading) {
    return <div className="p-4">Loading sessions...</div>;
  }

  if (error) {
    return <div className="p-4 text-red-600">Error: {error}</div>;
  }

  return (
    <div className="min-h-screen bg-gray-50">
    <Navbar />
      <main className="max-w-4xl mx-auto px-4 py-8">
        <h1 className="text-2xl font-bold mb-6 text-gray-800">Your Sessions</h1>
        {sessions.length === 0 ? (
          <p>No sessions found.</p>
        ) : (
          <ul className="space-y-4">
            {sessions.map((session) => (
              <li
                key={session.session_id}
                className="border p-4 rounded bg-white flex justify-between"
              >
                <div>
                  <h2 className="text-lg font-semibold text-gray-600">
                    {session.session_name}
                  </h2>
                  <p className="text-sm text-gray-600">
                    Created: {new Date(session.created_at).toLocaleString()}
                  </p>
                  {/* <p className="text-sm text-gray-600">Files: {session.file_count}</p> */}
                </div>
                <div className="flex items-center gap-2">
                  {/* View Details */}
                  <button
                    onClick={() => router.push(`/history/${session.session_id}`)}
                    className="bg-blue-600 text-white px-3 py-1 rounded hover:bg-blue-700"
                  >
                    View Details
                  </button>

                      {/* NEW "Load Session" button */}
                  <button
                    onClick={() => {
                      // 1) store in local storage
                      localStorage.setItem('currentSessionId', String(session.session_id));
                      // 2) push to dashboard
                      router.push(`/dashboard?sessionId=${session.session_id}`);
                    }}
                    className="bg-green-600 text-white px-3 py-1 rounded hover:bg-green-700"
                  >
                    Load Session
                  </button>

                  {/* Delete Session (opens our custom modal) */}
                  <button
                    onClick={() => handleOpenDeleteModal(session)}
                    className="p-2 hover:bg-red-50 rounded"
                    title="Delete Session"
                  >
                    <TrashIcon className="w-5 h-5 text-red-600" />
                  </button>
                </div>
              </li>
            ))}
          </ul>
        )}
      </main>

      {/* Our custom modal for delete confirmation */}
      {showDeleteModal && selectedSession && (
        <div className="fixed inset-0 flex items-center justify-center bg-black bg-opacity-50 z-50">
          <div className="bg-white p-6 rounded shadow-md max-w-sm w-full">
            <h2 className="text-xl font-semibold text-gray-800 mb-4">
              Delete Session
            </h2>
            <p className="text-gray-700 mb-6">
              Are you sure you want to delete the session "<strong>{selectedSession.session_name}</strong>"?
              <br />
              This action is <strong>permanent</strong> and cannot be undone.
            </p>
            <div className="flex justify-end gap-3">
              <button
                onClick={handleCloseDeleteModal}
                className="px-4 py-2 bg-gray-200 hover:bg-gray-300 text-gray-700 rounded"
              >
                Cancel
              </button>
              <button
                onClick={handleConfirmDelete}
                className="px-4 py-2 bg-red-600 hover:bg-red-700 text-white rounded"
              >
                Confirm Delete
              </button>
            </div>
          </div>
        </div>
      )}
    </div>
  );
}
----------------------------------------

File: app/history/[sessionId]/page.tsx
----------------------------------------
// app/history/[sessionId]/page.tsx
'use client';

import { useEffect, useState } from 'react';
import { useParams } from 'next/navigation';
import Navbar from '@/components/Navbar';
import Footer from '@/components/Footer';
import ReactJson from 'react-json-view';
import * as XLSX from 'xlsx';
import { FileNode } from '@/components/FileTree';

// Define the structure of the session data stored in the database.
export interface SessionData {
  session_name: string;
  fileTree?: FileNode[];
  // You can add other properties (extractedTexts, summaries, chatHistory, etc.) here
  [key: string]: unknown;
}

// Define the session structure returned by your API.
export interface Session {
  session_data: SessionData;
  created_at: string;
  file_count: number;
}

// A helper function to recursively extract Excel files from the file tree.
const getExcelFiles = (nodes: FileNode[]): FileNode[] => {
  let files: FileNode[] = [];
  nodes.forEach((node) => {
    if (node.type === 'file' && /\.(xlsx|xls)$/i.test(node.name)) {
      files.push(node);
    }
    if (node.children && node.children.length > 0) {
      files = files.concat(getExcelFiles(node.children));
    }
  });
  return files;
};

// Component to preview an Excel file node.
const ExcelPreview: React.FC<{ node: FileNode }> = ({ node }) => {
  const [tableData, setTableData] = useState<string[][]>([]);
  const [error, setError] = useState<string>('');

  useEffect(() => {
    const parseExcel = async () => {
      if (!node.base64Data) {
        setError('No data available');
        return;
      }
      try {
        // Decode the base64 string into a binary string.
        const binaryStr = atob(node.base64Data);
        const len = binaryStr.length;
        const bytes = new Uint8Array(len);
        for (let i = 0; i < len; i++) {
          bytes[i] = binaryStr.charCodeAt(i);
        }
        // Parse the workbook using XLSX.
        const workbook = XLSX.read(bytes, { type: 'array' });
        const sheetName = workbook.SheetNames[0];
        const sheet = workbook.Sheets[sheetName];
        // Convert the sheet to an array-of-arrays (each row is an array).
        const data: (string | number | boolean | null)[][] = XLSX.utils.sheet_to_json<(string | number | boolean | null)[]>(sheet, { header: 1 });
        const stringData: string[][] = data.map(row => row.map(cell => cell !== null ? cell.toString() : ''));
        setTableData(stringData);
      } catch {
        setError('Error parsing Excel file');
      }
    };

    parseExcel();
  }, [node.base64Data]);

  return (
    <div className="mb-4">
      <h3 className="font-semibold text-gray-800">{node.name}</h3>
      {error ? (
        <p className="text-red-600">{error}</p>
      ) : tableData.length > 0 ? (
        <div className="overflow-x-auto">
          <table className="min-w-full border border-gray-300">
            <tbody>
              {tableData.slice(0, 10).map((row, rowIndex) => (
                <tr key={rowIndex} className="border-b border-gray-200">
                  {row.map((cell, cellIndex) => (
                    <td
                      key={cellIndex}
                      className="px-2 py-1 border-r border-gray-200 text-gray-800"
                    >
                      {cell !== undefined ? cell.toString() : ''}
                    </td>
                  ))}
                </tr>
              ))}
            </tbody>
          </table>
          {tableData.length > 10 && (
            <p className="text-sm text-gray-600 mt-2">Showing first 10 rows</p>
          )}
        </div>
      ) : (
        <p className="text-gray-800">No data to preview</p>
      )}
    </div>
  );
};

const SessionDetail: React.FC = () => {
  const { sessionId } = useParams();
  const [session, setSession] = useState<Session | null>(null);
  const [error, setError] = useState<string>('');

// Add this useEffect to fetch heavy data when the component mounts
useEffect(() => {

  const userId = localStorage.getItem('userId');
  if (!userId || !sessionId) return;

  const fetchHeavyData = async () => {
    try {
      const res = await fetch(`/api/store-heavy-data?sessionId=${sessionId}`);
      if (!res.ok) throw new Error('Failed to fetch heavy data');
      const heavyData = await res.json();
      // Merge heavy data into session data
      setSession(prev => prev ? {
        ...prev,
        session_data: {
          ...prev.session_data,
          extractedTexts: heavyData.extractedTexts,
          summaries: heavyData.summaries,
          rawResponses: heavyData.rawResponses
        }
      } : null);
    } catch (err) {
      if (err instanceof Error) {
        setError(err.message);
      } else {
        setError('An unknown error occurred');
      }
    }
  };

  async function fetchSession() {
    try {
      // 1) Minimal session info from the DB
      const sessRes = await fetch(`/api/sessions/${sessionId}`, {
        headers: { 'x-user-id': userId || '' },
      });
      if (!sessRes.ok) throw new Error('Failed to fetch session');
      const sessJson = await sessRes.json();
      // sessJson is { session: { session_id, session_name, created_at, ... } }

      // 2) Heavy data from local file
      const heavyRes = await fetch(`/api/store-heavy-data?sessionId=${sessionId}`);
      // If heavy data doesn’t exist, it might be 404. You can handle that gracefully.
      if (!heavyRes.ok) {
        console.warn('No heavy data found (maybe not uploaded yet).');
      }
      const heavyJson = heavyRes.ok ? await heavyRes.json() : {};

      // 3) Merge them together
      // Suppose your DB session JSON doesn't store `session_data` by default.
      // You can create a structure that includes fileTree, chatHistory, etc.
      setSession({
        // For example, you can store them like:
        session_data: {
          session_name: sessJson.session.session_name,
          fileTree: heavyJson.extractedTexts ? [] : [], // or reconstruct if you wish
          // Or you can do more advanced merges if you have them
          extractedTexts: heavyJson.extractedTexts || {},
          summaries: heavyJson.summaries || {},
        },
        created_at: sessJson.session.created_at,
        file_count: sessJson.session.file_count || 0,
      });
    } catch (err) {
      console.error('Error fetching session details:', err);
      setError(err instanceof Error ? err.message : 'Unknown error');
    }
  }

  if (sessionId) {
    fetchSession();
    fetchHeavyData();
  }
}, [sessionId]);

  if (error) {
    return (
      <div className="min-h-screen bg-gray-50 flex flex-col">
     
        <main className="max-w-7xl mx-auto px-4 py-8 flex-grow text-gray-800">
          <p className="text-red-600">{error}</p>
        </main>
   
      </div>
    );
  }

  if (!session) {
    return (
      <div className="min-h-screen bg-gray-50 flex flex-col">
    
        <main className="max-w-7xl mx-auto px-4 py-8 flex-grow text-gray-800">
          <p>Loading session details...</p>
        </main>
     
      </div>
    );
  }

  // Extract Excel files (if any) from the file tree stored in session_data.
  const excelFiles: FileNode[] = session.session_data.fileTree
    ? getExcelFiles(session.session_data.fileTree)
    : [];

  return (
    <div className="min-h-screen bg-gray-50 flex flex-col">
      <Navbar />
      <main className="max-w-7xl mx-auto px-4 py-8 flex-grow text-gray-800">
        <h1 className="text-2xl font-bold mb-6">Session Details</h1>
        <div className="mb-4">
          <p>
            <strong>Name:</strong>{' '}
            {session.session_data.session_name || 'Untitled Session'}
          </p>
          <p>
            <strong>Created:</strong>{' '}
            {new Date(session.created_at).toLocaleString()}
          </p>
          <p>
           {/* <strong>Files Count:</strong> {session.file_count}*/}
          </p>
        </div>

        <div className="mb-6">
          <h2 className="text-xl font-semibold mb-2">Session Data</h2>
          {/* A scrollable, collapsible JSON viewer */}
          <div className="max-h-96 overflow-y-auto bg-gray-100 p-4 rounded">
            <ReactJson
              src={session.session_data}
              theme="rjv-default"
              collapsed={2}
              displayDataTypes={false}
              style={{ fontSize: '0.875rem' }}
            />
          </div>
        </div>

        {excelFiles.length > 0 && (
          <div className="mb-6">
            <h2 className="text-xl font-semibold mb-2">Excel Files Preview</h2>
            {excelFiles.map((file, index) => (
              <ExcelPreview key={index} node={file} />
            ))}
          </div>
        )}
      </main>
      <Footer />
    </div>
  );
};

export default SessionDetail;

----------------------------------------

File: app/api/all-accounts/route.tsx
----------------------------------------
// app/api/all-accounts/route.ts
import { NextResponse } from "next/server"

const BASE_URL = process.env.NEXT_PUBLIC_EXTERNAL_API_BASE_URL 
const API_TOKEN = process.env.NEXT_PUBLIC_EXTERNAL_API_TOKEN  

export async function GET() {
  try {
    // Build remote URL
    const remoteUrl = `${BASE_URL}/all_accounts?api_token=${API_TOKEN}`
    console.log("Fetching from:", remoteUrl) 
    // Server-to-server fetch => no CORS issue
    const response = await fetch(remoteUrl)
    if (!response.ok) {
      return NextResponse.json(
        { error: `Upstream error: ${response.statusText}` },
        { status: response.status }
      )
    }

    const data = await response.json()
    return NextResponse.json(data)
  } catch (err) {
    console.error("Error in /api/all-accounts route:", err)
    return NextResponse.json({ error: "Internal server error" }, { status: 500 })
  }
}

----------------------------------------

File: app/api/llm/route.tsx
----------------------------------------
// File: app/api/llm/route.tsx
import { NextResponse } from 'next/server';
import pool from '@/utils/db';
import fs from 'fs';
import path from 'path';
import crypto from 'crypto';  // <-- For hashing our prompt

export const dynamic = 'force-dynamic';

const DEBUG_MODE_CREATE = process.env.NEXT_PUBLIC_DEBUG_MODE_CREATE === 'true';
const DEBUG_LOG_FILE = 'debug-responses.jsonl';


interface DeepSeekError {
  error: {
    message: string;
    type: string;
    code: string;
  };
}
function generateCacheKey({
  model,
  prompt,
  requestType,
  context
}: {
  model: string;
  prompt: string;
  requestType?: string;
  context?: string;
}): string {
  const raw = `${model}__${requestType ?? ''}__${context ?? ''}__${prompt}`;
  return crypto.createHash('sha256').update(raw).digest('hex');
}

/**
 * Returns the full file path for a given hash key.
 * We store in /data/cache by default; create that folder if it doesn’t exist.
 */
function getCacheFilePath(hashKey: string): string {
  const cacheDir = path.join(process.cwd(), 'data', 'cache');
  return path.join(cacheDir, `${hashKey}.json`);
}

/**
 * Attempts to read a cached response. Returns `null` if not found or parsing fails.
 */
function readFromCache(hashKey: string): { content: string; tokensUsed: number; responseTime: number } | null {
  const filePath = getCacheFilePath(hashKey);
  if (!fs.existsSync(filePath)) {
    return null;
  }
  try {
    const raw = fs.readFileSync(filePath, 'utf8');
    return JSON.parse(raw);
  } catch (err) {
    console.error('Cache read/parse error:', err);
    return null;
  }
}

/**
 * Writes LLM response data to the cache as JSON.
 */
function writeToCache(
  hashKey: string,
  data: { content: string; tokensUsed: number; responseTime: number }
): void {
  const filePath = getCacheFilePath(hashKey);
  fs.writeFileSync(filePath, JSON.stringify(data, null, 2), 'utf8');
}


function logLLMCall({
  prompt,
  model,
  requestType,
  userId,
  response,
  error,
  logId
}: {
  prompt: string;
  model: string;
  requestType: string;
  userId: string | null;
  response?: string;
  error?: string;
  logId?: string;
}) {
  try {
    const logsDir = path.join(process.cwd(), 'logs'); 
    if (!fs.existsSync(logsDir)) fs.mkdirSync(logsDir);
      
    const logFile = path.join(logsDir, 'llm-logs.txt');
    const timestamp = new Date().toISOString();

    let logEntry = `[${timestamp}] ${model} ${requestType}\n`;
    logEntry += `Prompt: ${prompt}\n`;
    if (response) logEntry += `Response: ${response}\n`;
    if (error) logEntry += `Error: ${error}\n`;
    logEntry += '----------------------------------------\n';

    fs.appendFileSync(logFile, logEntry, 'utf8');

    // 2) Structured debug logging when in create mode
    if (DEBUG_MODE_CREATE) {
      const debugFile = path.join(logsDir, DEBUG_LOG_FILE);
      const debugEntry = {
        timestamp,
        model,
        requestType,
        userId,
        logId,
        prompt,
        response,
        error
      };
      
      fs.appendFileSync(
        debugFile,
        JSON.stringify(debugEntry) + '\n',
        'utf8'
      );
    }
  } catch (err) {
    console.error('Failed to write LLM call log:', err);
  }
}

export async function POST(req: Request) {
  let body: any = {};
  try {
    body = await req.json();
  } catch (error) {
    return NextResponse.json({ error: "Invalid JSON body" }, { status: 400 });
  }

  const { prompt, context, history, model, format, requestType, logId, skipCache } = body || {};
  if (!prompt || typeof prompt !== 'string') {
    return NextResponse.json({ error: 'Invalid prompt' }, { status: 400 });
  }

  const userId = req.headers.get('x-user-id');
  const DEVELOPMENT = process.env.NEXT_PUBLIC_LLM_DEV_MODE === 'true';

  // === CACHING LOGIC BELOW ===
  // Generate cache key regardless of skipCache to handle errors
  const cacheKey = generateCacheKey({ model, prompt, requestType, context });
  
  // If skipCache is NOT set, check cache first
  let cached = null;
  if (!skipCache) {
    cached = readFromCache(cacheKey);
    if (cached) {
      return NextResponse.json({
        content: cached.content,
        tokensUsed: cached.tokensUsed,
        responseTime: cached.responseTime
      });
    }
  }

  // -------------
  // For local dev/test: Mock response quickly
  // -------------
  if (DEVELOPMENT) {
    // Log the call in dev mode anyway
    logLLMCall({
      prompt,
      model: model || 'no-model',
      requestType: requestType || 'unknown',
      userId,
      response: '[MOCKED] No actual LLM call made',
      logId
    });

    await new Promise(res => setTimeout(res, 500));
    return NextResponse.json({
      content: `[MOCK RESPONSE] ${model || 'no-model'} response...`,
      tokensUsed: 42,
    });
  }

  // -------------
  // Actual LLM call
  // -------------
  try {
    if (model?.startsWith('deepseek:')) {
      const deepseekKey = process.env.DEEPSEEK_API_KEY;
      if (!deepseekKey) {
        console.error('DeepSeek API key missing');
        return NextResponse.json(
          { error: 'DeepSeek API key not configured' },
          { status: 500 }
        );
      }

      const modelName = model.replace('deepseek:', '');
      const messages = [
        { role: 'system', content: context || 'You are a helpful assistant.' },
        ...(Array.isArray(history) ? history : []),
        { role: 'user', content: prompt },
      ];

      const requestPayload = {
        model: modelName,
        messages,
        temperature: 0.0,
        max_tokens: 8000,
        stream: false,
      };

      const startTime = Date.now();
      const response = await fetch('https://api.deepseek.com/v1/chat/completions', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          Authorization: `Bearer ${deepseekKey}`,
        },
        body: JSON.stringify(requestPayload),
      });
      const responseTime = Date.now() - startTime;
      const responseText = await response.text(); // Get raw response text

      if (!response.ok) {
        console.error('DeepSeek API Error Details:', {
          status: response.status,
          headers: Object.fromEntries(response.headers.entries()),
          body: responseText,
        });
        // Log the failed call
        logLLMCall({
          prompt,
          model,
          requestType: requestType || 'unknown',
          userId,
          error: `DeepSeek API Error: ${response.statusText}\nBody: ${responseText}`,
          logId
        });
        return NextResponse.json(
          { error: `DeepSeek API Error: ${response.statusText}`, details: responseText },
          { status: 500 }
        );
      }

      // Attempt to parse the JSON response from API
      try {
        const data = JSON.parse(responseText);
        let content = '';

        if (requestType === 'consolidation' || requestType === 'extract') {
          // For structured data
          const rawContent = data.choices?.[0]?.message?.content || '';
          content = rawContent.replace(/```json\s*/gi, '').replace(/```/g, '').trim();
        } else {
          // Summaries, chat, etc.
          content = data.choices?.[0]?.message?.content || '';
        }

        // Log the successful call
        logLLMCall({
          prompt,
          model,
          requestType: requestType || 'unknown',
          userId,
          response: content,
          logId
        });

        // Write to cache only if skipCache is false AND parsing succeeded
        if (!skipCache && cacheKey) {
          writeToCache(cacheKey, {
            content,
            tokensUsed: data.usage?.total_tokens || 0,
            responseTime
          });
        }

        return NextResponse.json({
          content,
          tokensUsed: data.usage?.total_tokens || 0,
          responseTime,
        });
      } catch (parseError) {
        // Write raw response to cache for debugging even if skipCache is true
        writeToCache(cacheKey, {
          content: responseText,
          tokensUsed: 0,
          responseTime
        });

        logLLMCall({
          prompt,
          model,
          requestType: requestType || 'unknown',
          userId,
          error: `Response JSON Parse Error: ${String(parseError)}`,
          response: responseText,
          logId
        });

        return NextResponse.json(
          {
            error: 'Failed to parse API response',
            response: responseText,
            cacheFileName: `${cacheKey}.json` // Include cache filename
          },
          { status: 500 }
        );
      }
    }

    // If we eventually supported openai: or other, handle here...
    return NextResponse.json({ error: 'Unsupported model provider' }, { status: 400 });
  } catch (error: any) {
    // Log any top-level error
    logLLMCall({
      prompt,
      model: model || 'unknown',
      requestType: requestType || 'unknown',
      userId,
      error: String(error),
      logId
    });

    console.error('LLM Processing Error:', error);
    return NextResponse.json(
      {
        error: 'LLM processing failed',
        details: error instanceof Error ? error.message : String(error),
      },
      { status: 500 }
    );
  }
}

----------------------------------------

File: app/api/test/route.tsx
----------------------------------------
// app/api/test/route.ts
import { NextResponse } from 'next/server';
import pool from '@/utils/db';

export async function GET() {
  try {
    const client = await pool.connect();
    const result = await client.query('SELECT * FROM files ORDER BY file_id;');
    client.release();

    return NextResponse.json(result.rows);
  } catch (error) {
    console.error('Error fetching data', error);
    return NextResponse.json({ error: 'Error fetching data' }, { status: 500 });
  }
}

----------------------------------------

File: app/api/countTokens/route.tsx
----------------------------------------


----------------------------------------

File: app/api/auth/signup/route.tsx
----------------------------------------
'use server';
import { NextResponse } from 'next/server';
import pool from '@/utils/db';
import bcrypt from 'bcryptjs';

export async function POST(request: Request) {
  try {
    const body = await request.json();
    const { email, password, company, reason } = body;
    if (!email || !password) {
      return NextResponse.json({ error: 'Email and password are required' }, { status: 400 });
    }
    const client = await pool.connect();
    // Check if the user already exists
    const userCheck = await client.query('SELECT * FROM users WHERE email = $1', [email]);
    if (userCheck && userCheck.rowCount !== null && userCheck.rowCount > 0) {
      client.release();
      return NextResponse.json({ error: 'User already exists' }, { status: 400 });
    }
    // Hash the password
    const salt = bcrypt.genSaltSync(10);
    const password_hash = bcrypt.hashSync(password, salt);
    // Insert new user
    const result = await client.query(
      `INSERT INTO users (email, password_hash, company, reason) 
       VALUES ($1, $2, $3, $4) RETURNING user_id, email`,
      [email, password_hash, company, reason]
    );
    client.release();
    return NextResponse.json({ success: true, user: result.rows[0] }, { status: 200 });
  } catch (error) {
    console.error('Error in signup:', error);
    return NextResponse.json({ error: 'Error signing up' }, { status: 500 });
  }
}

----------------------------------------

File: app/api/auth/login/route.tsx
----------------------------------------
'use server';
import { NextResponse } from 'next/server';
import pool from '@/utils/db';
import bcrypt from 'bcryptjs';

export async function POST(request: Request) {
  try {
    const body = await request.json();
    const { email, password } = body;
    if (!email || !password) {
      return NextResponse.json({ error: 'Email and password are required' }, { status: 400 });
    }
    const client = await pool.connect();
    const userRes = await client.query('SELECT * FROM users WHERE email = $1', [email]);
    client.release();
    if (userRes.rowCount === 0) {
      return NextResponse.json({ error: 'Invalid credentials' }, { status: 401 });
    }
    const user = userRes.rows[0];
    const passwordMatch = bcrypt.compareSync(password, user.password_hash);
    if (!passwordMatch) {
      return NextResponse.json({ error: 'Invalid credentials' }, { status: 401 });
    }
    // Return user data (do not include the password hash)
    const userData = { user_id: user.user_id, email: user.email };
    return NextResponse.json({ success: true, user: userData }, { status: 200 });
  } catch (error) {
    console.error('Error in login:', error);
    return NextResponse.json({ error: 'Error logging in' }, { status: 500 });
  }
}

----------------------------------------

File: app/api/company-facts/route.tsx
----------------------------------------
// app/api/company-facts/route.ts

import { NextResponse } from "next/server"

// We'll assume you're using .env for the base URL and token.
// If not, you can hardcode them here.
const BASE_URL = process.env.NEXT_PUBLIC_EXTERNAL_API_BASE_URL
const API_TOKEN = process.env.NEXT_PUBLIC_EXTERNAL_API_TOKEN

export async function GET(request: Request) {
  try {
    // 1) Extract query params from the incoming request
    const { searchParams } = new URL(request.url)
    // e.g. "320193"
    const cik = searchParams.get("cik") ?? ""

    // 2) Build the remote URL
    const remoteUrl = `${BASE_URL}/company_facts?cik=${cik}&api_token=${API_TOKEN}`

    console.log("Fetching from:", remoteUrl)

    // 3) Fetch from the external API (server-to-server, no CORS issues here)
    const response = await fetch(remoteUrl, {
      method: "GET",
    })

    if (!response.ok) {
      // e.g. 404, 500, ...
      return NextResponse.json(
        { error: `Upstream error: ${response.statusText}` },
        { status: response.status }
      )
    }

    // 4) Return the JSON response to the client
    const data = await response.json()
    return NextResponse.json(data)
  } catch (err) {
    return NextResponse.json({ error: "Internal server error" }, { status: 500 })
  }
}

----------------------------------------

File: app/api/uploads/route.tsx
----------------------------------------
// app/api/uploads/route.ts
import { NextResponse } from 'next/server';
import pool from '@/utils/db';
import { FileNode } from '@/components/FileTree';

export async function GET(request: Request) {
  const userId = request.headers.get('x-user-id');
  if (!userId) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }

  try {
    const client = await pool.connect();
    // 1) Fetch all uploads for this user:
    const uploadsResult = await client.query(`
      SELECT upload_id, upload_name, created_at
      FROM uploads
      WHERE user_id = $1
      ORDER BY created_at DESC
    `, [userId]);

    const uploads = uploadsResult.rows;
    client.release();
    return NextResponse.json({ uploads });
  } catch (error) {
    console.error('Error fetching uploads:', error);
    return NextResponse.json({ error: 'Error fetching uploads' }, { status: 500 });
  }
}

export async function POST(request: Request) {
  let client;
  try {
    client = await pool.connect();
    const body = await request.json();
    const { uploadName, fileTree, extractedTexts, summaries, chatHistory } = body;

    // 1) Validate user ID from headers
    const userId = request.headers.get('x-user-id');
    if (!userId) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    // 2) Validate required fields
    if (!uploadName) {
      return NextResponse.json({ error: 'uploadName is required' }, { status: 400 });
    }

    // 3) Create a new "upload" row
    const insertUploadRes = await client.query(
      `INSERT INTO uploads (user_id, upload_name)
       VALUES ($1, $2)
       RETURNING upload_id`,
      [userId, uploadName]
    );
    const newUploadId = insertUploadRes.rows[0].upload_id;

    // 4) Gather all files from the fileTree
    const filesToInsert: Array<{
      fullPath: string;
      fileName: string;
      fileDataBase64?: string;
      mimeType: string;
    }> = [];

    function traverseTree(nodes: FileNode[]) {
      for (const node of nodes) {
        if (node.type === 'file') {
          filesToInsert.push({
            fullPath: node.fullPath || '',
            fileName: node.name,
            fileDataBase64: node.base64Data, // base64 string from the frontend
            mimeType: node.mimeType || 'application/octet-stream'
          });
        }
        if (node.children?.length) {
          traverseTree(node.children);
        }
      }
    }
    traverseTree(fileTree || []);

    // 5) Insert each file row + extraction if applicable
    for (const file of filesToInsert) {
      const fileDataBuffer = file.fileDataBase64
        ? Buffer.from(file.fileDataBase64, 'base64')
        : null;

      // Insert a row in "files"
      const insertFileRes = await client.query(
        `INSERT INTO files (upload_id, file_name, file_path, mime_type, file_data, is_extracted)
         VALUES ($1, $2, $3, $4, $5, $6)
         RETURNING file_id`,
        [
          newUploadId,
          file.fileName,
          file.fullPath,
          file.mimeType,
          fileDataBuffer,
          false
        ]
      );

      const fileId = insertFileRes.rows[0].file_id;

      // If there's text or summary, insert into "extractions"
      const extractedText = extractedTexts?.[file.fullPath];
      const summary = summaries?.[file.fullPath];
      if (extractedText || summary) {
        // Mark file as extracted
        await client.query(
          `UPDATE files SET is_extracted = TRUE WHERE file_id = $1`,
          [fileId]
        );

        // Insert into "extractions"
        await client.query(
          `INSERT INTO extractions (file_id, extracted_text, summarized_text)
           VALUES ($1, $2, $3)`,
          [fileId, extractedText || null, summary || null]
        );
      }
    }

    client.release();

    // Return the upload_id and chatHistory (if any)
    return NextResponse.json(
      { upload_id: newUploadId, chatHistory },
      { status: 200 }
    );
  } catch (error) {
    console.error('Error creating new upload:', error);
    if (client) client.release();
    return NextResponse.json(
      { error: 'Error creating new upload' },
      { status: 500 }
    );
  }
}

----------------------------------------

File: app/api/uploads/[uploadId]/route.tsx
----------------------------------------

import { NextResponse } from 'next/server';
import pool from '@/utils/db';
import { FileNode } from '@/components/FileTree';


export async function DELETE(request: Request,{ params }: { params: { uploadId: string } }) {
  let client;
  try {
    client = await pool.connect();
    const uploadId = parseInt(params.uploadId,10);
    if(isNaN(uploadId)) {
      return NextResponse.json({ error:'Invalid upload ID'},{ status:400 });
    }
    //1) Find all files for this upload
    const fileRes = await client.query(
      'SELECT file_id FROM files WHERE upload_id=$1',[uploadId]
    );
    const fileIds = fileRes.rows.map(r=>r.file_id);
    //2) Delete extractions for these files
    if(fileIds.length>0) {
      await client.query(
        'DELETE FROM extractions WHERE file_id=ANY($1)',
        [fileIds]
      );
    }
    //3) Delete files themselves
    await client.query('DELETE FROM files WHERE upload_id=$1',[uploadId]);
    //4) Finally delete the upload
    await client.query('DELETE FROM uploads WHERE upload_id=$1',[uploadId]);
    client.release();
    return NextResponse.json({ success:true },{ status:200 });
  } catch(error) {
    console.error('Error deleting entire upload:',error);
    if(client) client.release();
    return NextResponse.json({ error:'Error deleting upload'},{ status:500 });
  }
}


export async function PATCH(request: Request,{ params }: { params: { uploadId: string } }) {
  let client;
  try {
    client = await pool.connect();
    const uploadId = parseInt(params.uploadId, 10);
    if (isNaN(uploadId)) {
      return NextResponse.json({ error: 'Invalid upload ID' }, { status: 400 });
    }

    const body = await request.json();
    const { fileTree, extractedTexts, summaries } = body;
    const filesToInsert: Array<{
      fullPath: string;
      fileName: string;
      fileDataBase64?: string;
      mimeType: string;
    }> = [];

    function traverseTree(nodes: FileNode[]) {
      for (const node of nodes) {
        if (node.type === 'file') {
          filesToInsert.push({
            fullPath: node.fullPath || '',
            fileName: node.name,
            fileDataBase64: node.base64Data, // from front end
            mimeType: node.mimeType || 'application/octet-stream'
          });
        }
        if (node.children?.length) traverseTree(node.children);
      }
    }
    traverseTree(fileTree);

    // For each file, either insert or update
    for (const file of filesToInsert) {
      const existingFileRes = await client.query(
        `SELECT file_id FROM files WHERE upload_id = $1 AND file_path = $2`,
        [uploadId, file.fullPath]
      );
      let fileId: number;
      if (existingFileRes.rowCount && existingFileRes.rowCount > 0) {
        fileId = existingFileRes.rows[0].file_id;
        // Potentially update file_data if new base64 data is provided
        if (file.fileDataBase64) {
          const fileDataBuffer = Buffer.from(file.fileDataBase64, 'base64');
          await client.query(
            `UPDATE files
                SET file_data = $2, mime_type=$3
              WHERE file_id = $1`,
            [fileId, fileDataBuffer, file.mimeType]
          );
        }
      } else {
        // Insert new file row
        const fileDataBuffer = file.fileDataBase64
          ? Buffer.from(file.fileDataBase64, 'base64')
          : null;
        const insertRes = await client.query(
          `INSERT INTO files (upload_id, file_name, file_path, mime_type, file_data, is_extracted)
           VALUES ($1, $2, $3, $4, $5, $6)
           RETURNING file_id`,
          [
            uploadId,
            file.fileName,
            file.fullPath,
            file.mimeType,
            fileDataBuffer,
            false
          ]
        );
        fileId = insertRes.rows[0].file_id;
      }

      // Check if we have extraction for that path
      const extractedText = extractedTexts[file.fullPath];
      const summary = summaries[file.fullPath];
      if (extractedText || summary) {
        // Mark file as extracted
        await client.query(`UPDATE files SET is_extracted = TRUE WHERE file_id = $1`, [fileId]);
        // Upsert extraction
        const existingExtractRes = await client.query(
          `SELECT extraction_id FROM extractions WHERE file_id=$1`,
          [fileId]
        );
        if (existingExtractRes.rowCount && existingExtractRes.rowCount > 0) {
          await client.query(
            `UPDATE extractions
                SET extracted_text=$2,
                    summarized_text=$3,
                    updated_at=NOW()
              WHERE file_id=$1`,
            [fileId, extractedText || null, summary || null]
          );
        } else {
          await client.query(
            `INSERT INTO extractions (file_id, extracted_text, summarized_text)
             VALUES ($1,$2,$3)`,
            [fileId, extractedText || null, summary || null]
          );
        }
      }
    }

    client.release();
    return NextResponse.json({ success: true, message: 'Upload updated.' });
  } catch (error) {
    console.error('Error updating upload:', error);
    if (client) client.release();
    return NextResponse.json({ error: 'Error updating upload' }, { status: 500 });
  }
}

----------------------------------------

File: app/api/financial-data/route.tsx
----------------------------------------
// app/api/financial-data/route.ts
import { NextResponse } from "next/server"
import { Pool } from 'pg';

const pool = new Pool({
    port: 5432,
    host: 'localhost',
    user: 'postgres',
    password: '1234',
    database: 'sec_financial_data',
});

export async function GET(request: Request) {
  try {
    // 1) Parse query params from the URL
    const { searchParams } = new URL(request.url)
    const nameParam = (searchParams.get("name") ?? "").trim().toLowerCase()
    const tickerParam = (searchParams.get("ticker") ?? "").trim().toLowerCase()
    const cikParam = (searchParams.get("cik") ?? "").trim()

    // 2) Prepare placeholders.
    //    For name, we use a LIKE pattern if it's not empty: '%<name>%'
    //    For ticker, we do an exact match but case-insensitive, so we store it in lowercase and compare with LOWER(t.ticker).
    //    For cik, we do an exact match.
    const nameFilter = nameParam ? `%${nameParam}%` : ""
    const tickerFilter = tickerParam // empty if none provided
    const cikFilter = cikParam // empty if none provided

    // 3) Connect to the database
    const client = await pool.connect()

    // 4) Build and run the query
    //    Explanation:
    //    - LEFT JOIN `tickers` so we can gather possible tickers per `companies` row
    //    - Filter with a combination of name, ticker, and/or cik
    //    - If the corresponding parameter is empty, we skip that filter
    //    - Group by c.cik, c.name so we can do array_agg on the tickers
    const sql = `
      SELECT
        c.cik,
        c.name,
        ARRAY_AGG(t.ticker) AS tickers
      FROM companies c
      LEFT JOIN tickers t ON c.cik = t.cik
      WHERE
        ($1 = '' OR LOWER(c.name) LIKE $1)
        AND ($2 = '' OR LOWER(t.ticker) = $2)
        AND ($3 = '' OR c.cik = $3)
      GROUP BY c.cik, c.name
      ORDER BY c.name ASC
      LIMIT 50;
    `

    const result = await client.query(sql, [
      nameFilter,
      tickerFilter,
      cikFilter,
    ])

    client.release()

    // 5) Return JSON response
    return NextResponse.json(result.rows)
  } catch (error) {
    console.error("Error in /api/financial-data:", error)
    return NextResponse.json(
      { error: "Internal server error" },
      { status: 500 }
    )
  }
}

----------------------------------------

File: app/api/search/route.tsx
----------------------------------------
// app/api/search/route.ts
import { NextResponse } from 'next/server';
import pool from '../../../utils/db';

export async function GET(request: Request) {
  const { searchParams } = new URL(request.url);
  const query = searchParams.get('query') || '';

  try {
    const client = await pool.connect();
    const searchQuery = `
      SELECT 
        c.cik,
        c.name,
        ARRAY_AGG(t.ticker) as tickers,
        ts_rank(to_tsvector('english', c.name), plainto_tsquery('english', $1)) as rank
      FROM companies c
      LEFT JOIN tickers t ON c.cik = t.cik
      WHERE 
        to_tsvector('english', c.name) @@ plainto_tsquery('english', $1) OR
        t.ticker = $1 OR
        c.cik = $1
      GROUP BY c.cik, c.name
      ORDER BY rank DESC
      LIMIT 10;
    `;

    const result = await client.query(searchQuery, [query]);
    client.release();

    return NextResponse.json(result.rows.map(row => ({
      ...row,
      searchTerm: row.tickers.includes(query.toUpperCase()) ? query.toUpperCase() : row.cik === query ? query : row.name
    })));
  } catch  {
    return NextResponse.json(
      { error: 'Internal server error' },
      { status: 500 }
    );
  }
}
----------------------------------------

File: app/api/sessions/route.tsx
----------------------------------------
// app/api/sessions/route.tsx
import { NextResponse } from 'next/server';
import pool from '../../../utils/db';
// app/api/sessions/route.tsx
export async function GET(request: Request) {
  const client = await pool.connect();
  try {
    const userId = request.headers.get('x-user-id');
    if (!userId || isNaN(parseInt(userId))) { // Add numeric validation
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }
  

    const result = await client.query(`
      SELECT 
        s.session_id,
        s.session_name,
        s.created_at,
        (SELECT COUNT(*)::int FROM files f WHERE f.session_id = s.session_id) AS file_count
      FROM sessions s
      WHERE s.user_id = $1
      ORDER BY s.created_at DESC
    `, [userId]);


    
    const sessions = result.rows.map((row) => ({
      session_id: row.session_id,
      session_name: row.session_name,
      created_at: row.created_at,
      file_count: row.file_count
    }));

    return NextResponse.json({ sessions });
  } catch (error) {
    console.error('Session load error:', error);
    //alert(error);
    return NextResponse.json({ error: 'Failed to load sessions' }, { status: 500 });
  } finally {
    client.release();
  }
}



export async function POST(request: Request) {
  const client = await pool.connect();
  await client.query('BEGIN');
  try {
    const userId = request.headers.get('x-user-id');
    if (!userId) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const { sessionName } = await request.json();


    //columns  session_id | user_id | session_name | created_at | expires_at
    const result = await client.query(`
      INSERT INTO sessions (user_id, session_name)
      VALUES ($1, $2)
      RETURNING session_id, created_at
    `, [userId, sessionName]);

   
    const sessionId = result.rows[0].session_id;

    await client.query('COMMIT');
    return NextResponse.json({
      success: true,
      session_id: sessionId,
      created_at: result.rows[0].created_at
    });
  } catch (error) {
    await client.query('ROLLBACK');
    console.error('Session save error:', error);
    return NextResponse.json({ error: 'Failed to save session' }, { status: 500 });
  } finally {
    client.release();
  }
}
----------------------------------------

File: app/api/sessions/[sessionId]/route.tsx
----------------------------------------
// app/api/sessions/[sessionId]/route.tsx
import { NextResponse } from 'next/server';
import pool from '@/utils/db';
import fs from 'fs';
import path from 'path';

export async function GET(
  request: Request,
  { params }: { params: { sessionId: string } }
) {
  const client = await pool.connect();
  try {
    const userId = request.headers.get('x-user-id');
    if (!userId) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }
    const sId = parseInt(params.sessionId, 10);
    if (isNaN(sId)) {
      return NextResponse.json({ error: 'Invalid session ID' }, { status: 400 });
    }

    const res = await client.query(
      `SELECT session_id, session_name, created_at
         FROM sessions
        WHERE session_id = $1 AND user_id = $2`,
      [sId, userId]
    );
    if (res.rowCount === 0) {
      return NextResponse.json({ error: 'Session not found' }, { status: 404 });
    }
    const session = res.rows[0];
    return NextResponse.json({ session });
  } catch (error) {
    console.error('Error fetching session:', error);
    return NextResponse.json({ error: 'Error fetching session' }, { status: 500 });
  } finally {
    client.release();
  }
}

export async function DELETE(
  request: Request,
  { params }: { params: { sessionId: string } }
) {
  const client = await pool.connect();
  await client.query('BEGIN');
  try {
    const userId = request.headers.get('x-user-id');
    if (!userId) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }
    const sId = parseInt(params.sessionId, 10);
    if (isNaN(sId)) {
      return NextResponse.json({ error: 'Invalid session ID' }, { status: 400 });
    }
    // Optionally, remove the session reference from files (set session_id to NULL)
    await client.query(
      `UPDATE files SET session_id = NULL WHERE session_id = $1 AND user_id = $2`,
      [sId, userId]
    );
    const deleteResult = await client.query(
      `DELETE FROM sessions WHERE session_id = $1 AND user_id = $2`,
      [sId, userId]
    );
    if (deleteResult.rowCount === 0) {
      // Nothing to delete or unauthorized
      await client.query('ROLLBACK');
      return NextResponse.json(
        { error: 'Session not found or not authorized' },
        { status: 404 }
      );
    }

    await client.query('COMMIT');

     // 3) Remove the session folder from disk (best-effort)
    // data/<sessionId> is the folder holding heavyData.json + /files
    const sessionPath = path.join(process.cwd(), 'data', String(sId));
    try {
      // Node 14 and below do not support fs.rmSync, so if you need older Node, use rmdirSync.
      fs.rmSync(sessionPath, { recursive: true, force: true });
      console.log(`Deleted directory: ${sessionPath}`);
    } catch (err) {
      // Not critical if folder removal fails – but we log it.
      console.error(`Failed to remove folder ${sessionPath}:`, err);
    }

    return NextResponse.json({ success: true });
  } catch (error) {
    await client.query('ROLLBACK');
    console.error('Error deleting session:', error);
    return NextResponse.json({ error: 'Error deleting session' }, { status: 500 });
  } finally {
    client.release();
  }
}

----------------------------------------

File: app/api/session-file/route.tsx
----------------------------------------
import { NextResponse } from 'next/server';
import fs from 'fs';
import path from 'path';
import mime from 'mime'; // install via `npm install mime` if you want to do more robust MIME detection

export async function GET(request: Request) {
  try {
    const { searchParams } = new URL(request.url);
    const sessionId = searchParams.get('sessionId');
    const filePath = searchParams.get('filePath');

    if (!sessionId || !filePath) {
      return NextResponse.json(
        { error: 'Missing sessionId or filePath' },
        { status: 400 }
      );
    }

    // Construct the absolute path on disk
    const absolutePath = path.join(
      process.cwd(),
      'data',
      sessionId,
      decodeURIComponent(filePath) // Add URI decoding
    );

    console.log('Serving file:', absolutePath);

    if (!fs.existsSync(absolutePath)) {
      return NextResponse.json({ error: 'File not found' }, { status: 404 });
    }

    // Read file from disk
    const fileBuffer = fs.readFileSync(absolutePath);

    // Infer MIME type from the filename extension, or fall back to octet-stream
    const mimeType = mime.getType(absolutePath) || 'application/octet-stream';

    const headers = {
      'Content-Type': mimeType,
      'Content-Disposition': `inline; filename="${path.basename(absolutePath)}"`,
    };
    // Add proper PDF content disposition
    if (mimeType === 'application/pdf') {
      headers['Content-Disposition'] = `inline; filename="${path.basename(absolutePath)}"`;
    } else {
      headers['Content-Disposition'] = `attachment; filename="${path.basename(absolutePath)}"`;
    }

    // Return the file bytes in the response
    return new NextResponse(fileBuffer, {
      headers: headers,
    });
  } catch (error) {
    console.error('Error serving file:', error);
    return NextResponse.json({ error: 'File serving error' }, { status: 500 });
  }
}

----------------------------------------

File: app/api/files/route.tsx
----------------------------------------
import { NextResponse } from 'next/server';
import pool from '@/utils/db';

export async function POST(request: Request) {
  const client = await pool.connect();
  try {
    const userId = request.headers.get('x-user-id');
    if (!userId) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const formData = await request.formData();
    const files = formData.getAll('files') as File[];
    
    if (!files || files.length === 0) {
      return NextResponse.json({ error: 'No files provided' }, { status: 400 });
    }

    const insertedFiles = [];
    
    for (const file of files) {
      const buffer = Buffer.from(await file.arrayBuffer());
      const result = await client.query(
        `INSERT INTO files 
         (user_id, file_name, file_type, file_data, session_id)
         VALUES ($1, $2, $3, $4, $5)
         RETURNING file_id`,
         [userId, file.name, file.type, buffer, request.headers.get('x-session-id')]
      );
      insertedFiles.push(result.rows[0].file_id);
    }

    return NextResponse.json({ success: true, fileIds: insertedFiles });
  } catch (error) {
    console.error('File upload error:', error);
    return NextResponse.json({ error: 'File upload failed' }, { status: 500 });
  } finally {
    client.release();
  }
}

export async function GET() {
  try {
    const client = await pool.connect();
    const result = await client.query(`SELECT * FROM files;`);
    client.release();

    return NextResponse.json(result.rows);
  } catch (error) {
    console.error(error);
    return NextResponse.json({ error: 'Error fetching files' }, { status: 500 });
  }
}

----------------------------------------

File: app/api/files/[fileId]/route.tsx
----------------------------------------
import { NextResponse } from 'next/server';
import pool from '@/utils/db';


export async function GET(
  request: Request,
  { params }: { params: { fileId: string } }
) {
  const client = await pool.connect();
  try {
    const fileId = parseInt(params.fileId);
    if (isNaN(fileId)) {
      return NextResponse.json({ error: 'Invalid file ID' }, { status: 400 });
    }

    const result = await client.query(
      `SELECT file_name, file_type, file_data 
       FROM files 
       WHERE file_id = $1`,
      [fileId]
    );

    if (result.rowCount === 0) {
      return NextResponse.json({ error: 'File not found' }, { status: 404 });
    }

    const file = result.rows[0];
    return new NextResponse(file.file_data, {
      headers: {
        'Content-Type': file.file_type,
        'Content-Disposition': `attachment; filename="${file.file_name}"`
      }
    });
  } catch (error) {
    console.error('File download error:', error);
    return NextResponse.json({ error: 'File download failed' }, { status: 500 });
  } finally {
    client.release();
  }
}

export async function DELETE(
  request: Request,
  { params }: { params: { fileId: string } }
) {
  let client;
  try {
    client = await pool.connect();
    const fileId = parseInt(params.fileId, 10);
    if (isNaN(fileId)) {
      return NextResponse.json({ error: 'Invalid file ID' }, { status: 400 });
    }

    // Remove any extractions for this file, then remove the file itself
    await client.query('DELETE FROM extractions WHERE file_id = $1', [fileId]);
    await client.query('DELETE FROM files WHERE file_id = $1', [fileId]);

    client.release();
    return NextResponse.json({ success: true }, { status: 200 });
  } catch (error) {
    console.error('Error deleting file:', error);
    if (client) client.release();
    return NextResponse.json({ error: 'Error deleting file' }, { status: 500 });
  }
}

----------------------------------------

File: app/api/submission-history/route.tsx
----------------------------------------
// app/api/submission-history/route.ts

import { NextResponse } from "next/server"

const BASE_URL = process.env.NEXT_PUBLIC_EXTERNAL_API_BASE_URL
const API_TOKEN = process.env.NEXT_PUBLIC_EXTERNAL_API_TOKEN

export async function GET(request: Request) {
  try {
    const { searchParams } = new URL(request.url)
    const cik = searchParams.get("cik") ?? ""

    const remoteUrl = `${BASE_URL}/submission_history?cik=${cik}&api_token=${API_TOKEN}`
    const response = await fetch(remoteUrl, { method: "GET" })
    if (!response.ok) {
      return NextResponse.json(
        { error: `Upstream error: ${response.statusText}` },
        { status: response.status }
      )
    }

    const data = await response.json()
    return NextResponse.json(data)
  } catch (err) {
    console.error("Error in /api/submission-history route:", err)
    return NextResponse.json({ error: "Internal server error" }, { status: 500 })
  }
}

----------------------------------------

File: app/api/account-data/route.tsx
----------------------------------------
// app/api/account-data/route.ts
import { NextResponse } from "next/server"

const BASE_URL = process.env.NEXT_PUBLIC_EXTERNAL_API_BASE_URL
const API_TOKEN = process.env.NEXT_PUBLIC_EXTERNAL_API_TOKEN

export async function GET(request: Request) {
  try {
    const { searchParams } = new URL(request.url)
    // e.g. "AccountsPayableCurrent"
    const accountParam = searchParams.get("account") ?? ""
    // e.g. "2022" or "2023"
    const yearParam = searchParams.get("year") ?? ""

    if (!accountParam) {
      return NextResponse.json({ error: "Missing 'account' query param" }, { status: 400 })
    }

    // Remote endpoint might be something like:
    //    /all_data_for_account?account=AccountsPayableCurrent&year=2022&api_token=...
    const remoteUrl = `${BASE_URL}/all_data_for_account?account=${accountParam}&year=${yearParam}&api_token=${API_TOKEN}`

    const response = await fetch(remoteUrl)
    if (!response.ok) {
      return NextResponse.json(
        { error: `Upstream error: ${response.statusText}` },
        { status: response.status }
      )
    }

    const data = await response.json()
    return NextResponse.json(data)
  } catch (err) {
    console.error("Error in /api/account-data route:", err)
    return NextResponse.json({ error: "Internal server error" }, { status: 500 })
  }
}

----------------------------------------

File: app/api/store-heavy-data/route.tsx
----------------------------------------
// app/api/store-heavy-data/route.ts
import { NextResponse } from 'next/server';
import fs from 'fs';
import path from 'path';
import { FileNode } from '@/components/FileTree';

export async function POST(request: Request) {
  try {
    const { sessionId, heavyData } = await request.json();
    if (!sessionId) {
      return NextResponse.json({ error: 'sessionId is required' }, { status: 400 });
    }

    // 1) Create the directory structure: data/sessionId/files
    const dataDir = path.join(process.cwd(), 'data', sessionId.toString());
    if (!fs.existsSync(dataDir)) {
      fs.mkdirSync(dataDir, { recursive: true });
    }
    const filesDir = path.join(dataDir, 'files');
    if (!fs.existsSync(dataDir)) {
      fs.mkdirSync(dataDir, { recursive: true });
    }
    if (!fs.existsSync(filesDir)) {
      fs.mkdirSync(filesDir);
    }

    // 2) For each file node in fileTree, decode base64 -> raw file
    function storeFilesRecursively(nodes: FileNode[]): FileNode[] {
      return nodes.map((node, idx) => {
        if (node.type === 'folder' && node.children) {
          return { ...node, children: storeFilesRecursively(node.children) };
        }
        if (node.type === 'file' && node.base64Data) {
          // decode base64
          const buffer = Buffer.from(node.base64Data, 'base64');
          // create a unique filename. You can also keep the original name if you prefer
          // but we add idx or a timestamp to avoid collisions:
          const safeName = node.name.replace(/[^\w\d.]+/g, '_');
          const fileName = `file_${Date.now()}_${idx}_${safeName}`;
          const filePath = path.join(filesDir, fileName);

          // 3) Write the file to data/sessionId/files/
          fs.writeFileSync(filePath, buffer);

          // 4) Remove base64Data from the node, and add localPath
          return {
            ...node,
            base64Data: undefined,
            rawData: undefined,
            localPath: `files/${fileName}`
          };
        }
        return node;
      });
    }

    // If there's a fileTree, store each file on disk
    let updatedFileTree: FileNode[] = [];
    if (heavyData.fileTree) {
      updatedFileTree = storeFilesRecursively(heavyData.fileTree);
    }

    // 5) Overwrite heavyData.fileTree with the updated one
    const filePath = path.join(dataDir, 'heavyData.json');
    const existingData = fs.existsSync(filePath) 
                ? JSON.parse(fs.readFileSync(filePath, 'utf-8'))
                : {};

    const finalHeavyData = {
      ...existingData,
      ...heavyData,
      consolidatedCompanies: heavyData.consolidatedCompanies || [],
    };
    fs.writeFileSync(filePath, JSON.stringify(finalHeavyData, null, 2));
    return NextResponse.json({ success: true, filePath });
  } catch (error) {

    return NextResponse.json(
      { error: 'Failed to save heavy data' + error },
      { status: 500 }
    );
  }
}

export async function GET(request: Request) {
  const { searchParams } = new URL(request.url);
  const sessionId = searchParams.get('sessionId');

  if (!sessionId) {
    return NextResponse.json({ error: 'sessionId is required' }, { status: 400 });
  }

  try {
    const dataDir = path.join(process.cwd(), 'data', sessionId);
    const filePath = path.join(dataDir, 'heavyData.json');
    if (!fs.existsSync(filePath)) {
      return NextResponse.json({ error: 'No heavyData found' }, { status: 404 });
    }

    const data = fs.readFileSync(filePath, 'utf-8');
    return NextResponse.json(JSON.parse(data));
  } catch (error) {
    console.error('Error reading heavy data:', error);
    return NextResponse.json({ error: 'Heavy data not found' }, { status: 404 });
  }
}

----------------------------------------

File: app/data/page.tsx
----------------------------------------
"use client";

import { useState } from "react";
import { SearchForm } from "@/components/ui/search-form";
import { SearchResults } from "@/components/ui/search-results";
import { Skeleton } from "@/components/ui/skeleton";
import Navbar from "@/components/Navbar";

// If you have a Navbar component like in HistoryPage, import it:
// import Navbar from "@/components/Navbar";

export default function DataPage() {
  const [results, setResults] = useState([]);
  const [isSearching, setIsSearching] = useState(false);

  async function handleSearch(params: { name: string; ticker: string; cik: string }) {
    console.log("Searching with:", params); // <-- Debug log
    setIsSearching(true);
    try {
      // Construct a query string with name, ticker, cik
      const searchParams = new URLSearchParams({
        name: params.name.trim(),
        ticker: params.ticker.trim(),
        cik: params.cik.trim(),
      });

      const response = await fetch(`/api/financial-data?${searchParams.toString()}`);
      const data = await response.json();
      console.log("Data received:", data); // <-- Debug log
      setResults(data || []);
    } catch (error) {
      console.error("Error fetching financial data:", error);
      setResults([]);
    } finally {
      setIsSearching(false);
    }
  }

  return (
    <div className="min-h-screen bg-gray-50">
     
      <main className="max-w-4xl mx-auto px-4 py-8">
        <h1 className="text-2xl font-bold mb-6 text-gray-800 text-center">
          SEC Financial Data Explorer
        </h1>

        {/* Our new SearchForm component */}
        <SearchForm onSearch={handleSearch} />

        {/* Results or loading skeletons */}
        {isSearching ? (
          <div className="mt-8 space-y-4">
            {[...Array(3)].map((_, i) => (
              <Skeleton key={i} className="h-6 w-full" />
            ))}
          </div>
        ) : (
          <div className="mt-8">
            <SearchResults results={results} />
          </div>
        )}
      </main>
    </div>
  );
}

----------------------------------------

File: app/data/[cik]/page.tsx
----------------------------------------
// app/data/[cik]/page.tsx
export const dynamic = "force-dynamic";
import { CompanyFactsPage } from "@/components/ui/company-facts-page";
import Navbar from "@/components/Navbar";
interface CompanyDataPageProps {
  params: {
    cik: string;
  };
}



export default async function CompanyDataPage({ params }: CompanyDataPageProps) {
  const { cik } = await params;

  return (
    <div className="min-h-screen bg-gray-50">
      <Navbar />
      <main className="max-w-4xl mx-auto px-4 py-8">
        <h1 className="text-2xl font-bold mb-6 text-gray-800 text-center">
          Company Financial Facts & Info
        </h1>

        {/* Our client component with all the logic */}
        <CompanyFactsPage cik={cik} />
      </main>
    </div>
  );
}

----------------------------------------

File: app/login/page.tsx
----------------------------------------
// app/login/page.tsx
'use client';

import { useState } from 'react';
import { useRouter } from 'next/navigation';
import Link from 'next/link';
import Navbar from '@/components/Navbar';

export default function LoginPage() {
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [error, setError] = useState<string | null>(null);
  const router = useRouter();

  const handleLogin = async (e: React.FormEvent) => {
    e.preventDefault();
    setError(null);
    if (!email || !password) {
      setError('Please enter both email and password');
      return;
    }
    try {
      const res = await fetch('/api/auth/login', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ email, password }),
      });
      const data = await res.json();
      if (!res.ok) {
        throw new Error(data.error || 'Login failed');
      }
      // Save login details from the response
      localStorage.setItem('loggedIn', 'true');
      localStorage.setItem('userEmail', data.user.email);
      localStorage.setItem('userId', String(data.user.user_id));
      router.push('/dashboard');
    } catch (err) {
      console.error('Login Error:', err);
      setError('Invalid email or password');
    }
  };

  return (
    <div className="min-h-screen bg-gray-50">
<Navbar />
      <main className="flex items-center justify-center px-4 py-12">
        <div className="w-full max-w-md bg-white rounded-lg shadow-md p-8">
          <h1 className="text-2xl font-bold text-center text-blue-600 mb-6">Welcome Back</h1>
          {error && <p className="text-red-600 text-sm">{error}</p>}
          <form onSubmit={handleLogin} className="space-y-4">
            <div>
              <label className="block text-gray-700 text-sm font-medium mb-1">Email</label>
              <input
                type="email"
                className="w-full border border-gray-300 rounded-md p-2"
                value={email}
                onChange={(e) => setEmail(e.target.value)}
                required
                placeholder="Enter your email"
              />
            </div>
            <div>
              <label className="block text-gray-700 text-sm font-medium mb-1">Password</label>
              <input
                type="password"
                className="w-full border border-gray-300 rounded-md p-2"
                value={password}
                onChange={(e) => setPassword(e.target.value)}
                required
                placeholder="Enter your password"
              />
            </div>
            <button
              type="submit"
              className="w-full bg-blue-600 text-white py-2 rounded-md hover:bg-blue-700 transition-colors"
            >
              Log In
            </button>
          </form>
          <div className="mt-4 text-center text-sm text-gray-600">
            Don&apos;t have an account?{' '}
            <Link href="/signup" className="text-blue-600 hover:underline">
              Sign Up
            </Link>
          </div>
        </div>
      </main>
    </div>
  );
}

----------------------------------------

File: app/companies/page.tsx
----------------------------------------
// app/companies/page.tsx
'use client';

import React, { useEffect, useState } from 'react';  // <-- ensure React is imported
import { useSearchParams } from 'next/navigation';
import Navbar from '@/components/Navbar';
import { useRouter } from 'next/navigation';
import { SessionSummary } from '@/app/history/page'; // or define your own type if needed

interface VariableData {
  value?: number | string;
  currency?: string;
  unit?: string;
  sources: Array<{
    filePath: string;
    pageNumber?: number;
    confidence?: number;
  }>;
  [year: number]: {
    value?: number | string;
    currency?: string;
    unit?: string;
    sources: Array<{
      filePath: string;
      pageNumber?: number;
      confidence?: number;
    }>;
  };
}

interface ConsolidatedCompany {
  name: string;
  type: 'company' | 'fund';
  description: string;
  variables: Record<string, VariableData>;
  dates: string[];
  parent?: string;
  children?: ConsolidatedCompany[];
  ownershipPath: string[];
  sources: Array<{
    filePath: string;
    pageNumber?: number;
    confidence?: number;
  }>;
  // The following are optional properties that might be present for "fund" types or other data structures:
  investments?: Array<{
    company: string;
    ownershipPercentage?: number;
  }>;
  subsidiaries?: string[];
}

export default function CompaniesPage() {
  const router = useRouter();
  const searchParams = useSearchParams();
  const existingSessionId = searchParams.get('sessionId');
  
  const [companies, setCompanies] = useState<ConsolidatedCompany[]>([]);
  const [sessions, setSessions] = useState<SessionSummary[]>([]);
  const [loading, setLoading] = useState(true);
  const [selectedYears, setSelectedYears] = useState<Record<string, number>>({});
  const [expandedOwnership, setExpandedOwnership] = useState<Set<string>>(new Set());

  // New state for raw JSON toggling
  const [shownJson, setShownJson] = useState<Set<string>>(new Set());

  useEffect(() => {
    const userId = localStorage.getItem('userId');
    if (!userId) return; // Not logged in
    fetch('/api/sessions', {
      headers: { 'x-user-id': userId }
    })
      .then(r => r.json())
      .then(data => {
        if (data.sessions) {
          setSessions(data.sessions);
        }
      })
      .catch(err => {
        console.error('Error fetching sessions for Companies page:', err);
      });
  }, []);

  useEffect(() => {
    const fetchConsolidatedData = async () => {
      if (!existingSessionId) {
        setLoading(false);
        return;
      }
      try {
        const response = await fetch(`/api/store-heavy-data?sessionId=${existingSessionId}`);
        if (!response.ok) throw new Error('Failed to fetch data');
        const data = await response.json();

        if (data.consolidatedCompanies) {
          setCompanies(data.consolidatedCompanies);
        } else {
          setCompanies([]);
        }
      } catch (error) {
        console.error('Error loading companies:', error);
      } finally {
        setLoading(false);
      }
    };

    fetchConsolidatedData();
  }, [existingSessionId]);

  // Add conditional rendering for the "no company data retrieved" message
  if (searchParams.get('message') === 'noData') {
    return (
      <div className="min-h-screen bg-gray-50 text-gray-600">
        <main className="max-w-7xl mx-auto px-4 py-8">
          <p className="text-center text-gray-600">No company data retrieved.</p>
        </main>
      </div>
    );
  }

  const getCompanyYears = (company: ConsolidatedCompany): number[] => {
    const years = new Set<number>();
    Object.values(company.variables).forEach(variable => {
      Object.keys(variable).forEach(yearStr => {
        const year = parseInt(yearStr, 10);
        if (!isNaN(year)) years.add(year);
      });
    });
    return Array.from(years).sort((a, b) => b - a);
  };

  if (loading) {
    return (
      <div className="min-h-screen bg-gray-50">
        <div className="max-w-7xl mx-auto px-4 py-8">
          <p>Loading...</p>
        </div>
      </div>
    );
  }

  const renderCompanySection = (type: 'company' | 'fund', color: string) => {
    const filteredCompanies = companies.filter(c => c.type === type);
    if (filteredCompanies.length === 0) return null;

    return (
      <div className="mb-8 text-gray-500">
        <h2 className="text-xl font-bold mb-4" style={{ color }}>
          {type === 'fund' ? 'Funds' : 'Companies'}
        </h2>
        {filteredCompanies.map(company => {
          const companyYears = getCompanyYears(company);
          const latestYear = companyYears[0] || null;
          const selectedYear = selectedYears[company.name] ?? latestYear;

          return (
            <div 
              key={company.name}
              className="bg-white p-6 rounded-lg shadow-sm mb-4 border-l-4"
              style={{ borderColor: color }}
            >
              <div className="flex justify-between items-center mb-4">
                <h2 className="text-xl font-semibold">{company.name}</h2>
                <div className="flex items-center gap-3">
                  {companyYears.length > 0 && (
                    <select
                      value={selectedYear || ''}
                      onChange={(e) => {
                        const year = parseInt(e.target.value, 10);
                        setSelectedYears(prev => ({
                          ...prev,
                          [company.name]: year
                        }));
                      }}
                      className="px-4 py-2 border rounded"
                    >
                      {companyYears.map(year => (
                        <option key={year} value={year}>{year}</option>
                      ))}
                    </select>
                  )}
                  <button
                    onClick={() => {
                      const newSet = new Set(expandedOwnership);
                      newSet.has(company.name) 
                        ? newSet.delete(company.name) 
                        : newSet.add(company.name);
                      setExpandedOwnership(newSet);
                    }}
                    className="px-3 py-1 bg-gray-200 rounded hover:bg-gray-300 text-sm"
                  >
                    {expandedOwnership.has(company.name) 
                      ? 'Hide Ownership' 
                      : 'Show Ownership'}
                  </button>
                </div>
              </div>
              
              {company.description && (
                <p className="text-gray-600 mb-4">{company.description}</p>
              )}

              <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                {/* Updated Variable Display Logic */}
                {Object.entries(company.variables).map(([varName, variableData]) => {
                  let varData: any = null;
                  
                  // Check for year-specific data
                  if (selectedYear !== null) {
                    varData = variableData[selectedYear];
                  } 
                  // Fallback to general value if no year is selected
                  else if (variableData.value !== undefined) {
                    varData = variableData;
                  }

                  return varData ? (
                    <div key={varName} className="p-4 rounded" style={{ backgroundColor: `${color}10` }}>
                      <div className="flex justify-between items-center">
                        <span className="font-medium capitalize">
                          {varName.replace(/_/g, ' ')}
                        </span>
                        <span className="text-sm text-gray-600">
                          {varData.currency} {varData.value?.toLocaleString()}
                          {varData.unit}
                        </span>
                      </div>
                      <div className="mt-2 text-xs text-gray-500">
                        Sources:
                        {varData.sources?.map((source: any, idx: number) => (
                          <div key={idx} className="mt-1">
                            • {source.filePath.split('/').pop()} 
                            {source.pageNumber && ` (Page ${source.pageNumber})`}
                          </div>
                        ))}
                      </div>
                    </div>
                  ) : null;
                })}
                
                {/* Conditionally Rendered Ownership Structure */}
                {expandedOwnership.has(company.name) && (
                  <div className="mt-4 p-4 bg-gray-50 rounded-lg">
                    <h3 className="text-lg font-semibold mb-2">Ownership Structure</h3>
                    <OwnershipTree company={company} />
                  </div>
                )}
              </div>

              {/* Show/Hide Raw Data Button & JSON Preview */}
              <div className="mt-4">
                <button
                  onClick={() => {
                    const newSet = new Set(shownJson);
                    newSet.has(company.name) 
                      ? newSet.delete(company.name) 
                      : newSet.add(company.name);
                    setShownJson(newSet);
                  }}
                  className="text-sm text-blue-600 hover:text-blue-800"
                >
                  {shownJson.has(company.name) ? 'Hide Raw Data' : 'Show Raw Data'}
                </button>
                
                {shownJson.has(company.name) && (
                  <div className="mt-2 p-3 bg-gray-50 rounded">
                    <pre className="text-xs overflow-auto max-h-96">
                      {JSON.stringify(company, null, 2)}
                    </pre>
                  </div>
                )}
              </div>
            </div>
          );
        })}
      </div>
    );
  };

  return (
    <div className="min-h-screen bg-gray-50">
      <Navbar />
      <main className="max-w-7xl mx-auto px-4 py-8">

        {/* Session Selector */}
        <div className="mb-4 text-gray-500">
          <label className="block text-gray-700 font-medium mb-1">Select Session:</label>
          <select
            className="border p-2 rounded"
            value={existingSessionId || ''}
            onChange={(e) => {
              const newSessionId = e.target.value;
              router.push(`/companies?sessionId=${newSessionId}`);
            }}
          >
            <option value="">-- Choose a session --</option>
            {sessions.map((s) => (
              <option key={s.session_id} value={s.session_id}>
                {s.session_name} (ID: {s.session_id})
              </option>
            ))}
          </select>
        </div>

        {renderCompanySection('fund', '#2563eb')}
        {renderCompanySection('company', '#16a34a')}
      </main>
    </div>
  );
}

// OwnershipTree component with investments and subsidiaries display
const OwnershipTree = ({ company }: { company: ConsolidatedCompany }) => (
  <div className="ml-4 border-l-2 border-gray-200 pl-4">
    {/* Existing ownership path */}
    {company.ownershipPath?.map((owner, idx) => (
      <div key={idx} className="text-sm text-gray-600">
        {idx === 0 ? 'Root Owner:' : '→'} {owner}
      </div>
    ))}
    
    {/* Display investments for funds */}
    {company.type === 'fund' && (company.investments ?? []).length > 0 && (
      <div className="mt-2">
        <h4 className="font-semibold text-sm mb-1">Investments:</h4>
        {(company.investments ?? []).map((investment, idx) => (
          <div key={idx} className="flex items-center gap-2 text-sm">
            <span>{investment.company}</span>
            {investment.ownershipPercentage && (
              <span className="text-gray-500">
                ({investment.ownershipPercentage}%)
              </span>
            )}
          </div>
        ))}
      </div>
    )}

    {/* Display subsidiaries */}
    {(company.subsidiaries ?? []).length > 0 && (
      <div className="mt-2">
        <h4 className="font-semibold text-sm mb-1">Subsidiaries:</h4>
        {(company.subsidiaries ?? []).map((sub, idx) => (
          <div key={idx} className="text-sm">{sub}</div>
        ))}
      </div>
    )}

    {/* Recursive children */}
    {company.children?.map(child => (
      <div key={child.name} className="mt-2">
        <div className="font-medium">{child.name}</div>
        <OwnershipTree company={child} />
      </div>
    ))}
  </div>
);

----------------------------------------

File: app/data-aggregated/page.tsx
----------------------------------------
// app/data-aggregated/page.tsx

"use client";

import React, { useEffect, useState } from "react";
import { Skeleton } from "@/components/ui/skeleton";

type AccountKey = string; // e.g. "AccountsPayableCurrent", "Assets", etc.
interface AccountDefinition {
  description: string;
  instant: number;       // 1 or 0
  name: string;
  taxonomy: string;      // e.g. "us-gaap"
  units: string;         // e.g. "USD" or "shares"
}

// Suppose the aggregated data from your remote returns array of objects
// e.g. { cik: '0000320193', year: 2022, value: 123456, ... }
interface AggregatedDataItem {
  cik: string;
  year: number;
  value: number;
  [key: string]: string | number;
}

export default function DataAggregatedPage() {
  // 1) States
  const [accounts, setAccounts] = useState<Record<AccountKey, AccountDefinition>>({})
  const [loadingAccounts, setLoadingAccounts] = useState(false)

  const [selectedAccount, setSelectedAccount] = useState<string>("")
  const [year, setYear] = useState<string>("2022")

  const [loadingData, setLoadingData] = useState(false)
  const [aggregatedData, setAggregatedData] = useState<AggregatedDataItem[]>([])

  const [error, setError] = useState<string>("")

  // 2) Fetch all accounts on mount
  useEffect(() => {
    async function fetchAccounts() {
      setLoadingAccounts(true)
      try {
        const res = await fetch("/api/all-accounts")
        if (!res.ok) {
          const err = await res.json()
          throw new Error(err.error || "Failed fetching accounts.")
        }
        const data = await res.json()
        setAccounts(data)
      } catch (err: unknown) {
        if (err instanceof Error) {
          setError(`Error: ${err.message}`)
        } else {
          setError("Unknown error fetching accounts.")
        }
      } finally {
        setLoadingAccounts(false)
      }
    }
    fetchAccounts()
  }, [])

  // 3) Function to load aggregated data for the chosen account
  async function handleLoadData() {
    if (!selectedAccount) {
      alert("Please select an account first.")
      return
    }

    setLoadingData(true)
    setAggregatedData([])
    setError("")

    try {
      // e.g. /api/account-data?account=AccountsPayableCurrent&year=2022
      const query = new URLSearchParams({
        account: selectedAccount,
        year: year || "",
      })
      const res = await fetch(`/api/account-data?${query.toString()}`)
      if (!res.ok) {
        const err = await res.json()
        throw new Error(err.error || "Failed fetching aggregated data.")
      }
      const data = await res.json()
      // data is presumably an array of { cik, value, ... }
      setAggregatedData(data)
    } catch (err: unknown) {
      if (err instanceof Error) {
        setError(`Error: ${err.message}`)
      } else {
        setError("Unknown error fetching aggregated data.")
      }
    } finally {
      setLoadingData(false)
    }
  }

  // 4) Render
  const accountKeys = Object.keys(accounts)

  return (
    <div className="min-h-screen bg-gray-50">
      <main className="max-w-4xl mx-auto px-4 py-8 space-y-6">
        <h1 className="text-2xl font-bold text-center text-gray-800 mb-4">
          Aggregated Data by Account
        </h1>

        {/* If error */}
        {error && <p className="text-red-600">{error}</p>}

        {/* Accounts dropdown */}
        <div className="bg-white p-4 shadow rounded space-y-4 text-gray-600">
          <label className="block font-semibold">Select an Account:</label>
          {loadingAccounts ? (
            <Skeleton className="h-6 w-full text-gray-600" />
          ) : (
            <select
              className="border rounded px-2 py-1 w-full text-sm"
              value={selectedAccount}
              onChange={(e) => setSelectedAccount(e.target.value)}
            >
              <option value="">-- Choose an account --</option>
              {accountKeys.map((key) => (
                <option key={key} value={key}>
                  {key} ({accounts[key].units})
                </option>
              ))}
            </select>
          )}

          {/* Optional year input */}
          <label className="block font-semibold">Year:</label>
          <input
            type="text"
            value={year}
            onChange={(e) => setYear(e.target.value)}
            placeholder="e.g. 2022"
            className="border rounded px-2 py-1 w-full text-sm"
          />

          {/* Button to load data */}
          <div className="text-right">
            <button
              onClick={handleLoadData}
              className="bg-blue-600 text-white px-4 py-2 rounded hover:bg-blue-700"
            >
              Load Aggregated Data
            </button>
          </div>
        </div>

        {/* Aggregated data results */}
        <div className="bg-white p-4 shadow rounded">
          {loadingData && <Skeleton className="h-4 w-full" />}
          {!loadingData && aggregatedData.length > 0 && (
            <div>
              <h2 className="font-semibold mb-2 text-lg">
                Results for {selectedAccount} ({year || "All Years"})
              </h2>
              <table className="w-full border text-sm">
                <thead>
                  <tr className="bg-gray-100">
                    <th className="border p-2 text-left">CIK</th>
                    <th className="border p-2 text-left">Year</th>
                    <th className="border p-2 text-left">Value</th>
                  </tr>
                </thead>
                <tbody>
                  {aggregatedData.map((item, idx) => (
                    <tr key={idx}>
                      <td className="border p-2">{item.cik}</td>
                      <td className="border p-2">{item.year}</td>
                      <td className="border p-2">{item.value}</td>
                    </tr>
                  ))}
                </tbody>
              </table>
            </div>
          )}

          {!loadingData && aggregatedData.length === 0 && (
            <p className="text-gray-600">No data loaded yet.</p>
          )}
        </div>
      </main>
    </div>
  );
}

----------------------------------------


