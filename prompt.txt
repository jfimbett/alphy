File: app/api\account-data\route.tsx
----------------------------------------
// app/api/account-data/route.ts
import { NextResponse } from "next/server"

const BASE_URL = process.env.NEXT_PUBLIC_EXTERNAL_API_BASE_URL
const API_TOKEN = process.env.NEXT_PUBLIC_EXTERNAL_API_TOKEN

export async function GET(request: Request) {
  try {
    const { searchParams } = new URL(request.url)
    // e.g. "AccountsPayableCurrent"
    const accountParam = searchParams.get("account") ?? ""
    // e.g. "2022" or "2023"
    const yearParam = searchParams.get("year") ?? ""

    if (!accountParam) {
      return NextResponse.json({ error: "Missing 'account' query param" }, { status: 400 })
    }

    // Remote endpoint might be something like:
    //    /all_data_for_account?account=AccountsPayableCurrent&year=2022&api_token=...
    const remoteUrl = `${BASE_URL}/all_data_for_account?account=${accountParam}&year=${yearParam}&api_token=${API_TOKEN}`

    const response = await fetch(remoteUrl)
    if (!response.ok) {
      return NextResponse.json(
        { error: `Upstream error: ${response.statusText}` },
        { status: response.status }
      )
    }

    const data = await response.json()
    return NextResponse.json(data)
  } catch (err) {
    console.error("Error in /api/account-data route:", err)
    return NextResponse.json({ error: "Internal server error" }, { status: 500 })
  }
}

----------------------------------------

File: app/api\all-accounts\route.tsx
----------------------------------------
// app/api/all-accounts/route.ts
import { NextResponse } from "next/server"

const BASE_URL = process.env.NEXT_PUBLIC_EXTERNAL_API_BASE_URL 
const API_TOKEN = process.env.NEXT_PUBLIC_EXTERNAL_API_TOKEN  

export async function GET() {
  try {
    // Build remote URL
    const remoteUrl = `${BASE_URL}/all_accounts?api_token=${API_TOKEN}`
    console.log("Fetching from:", remoteUrl) 
    // Server-to-server fetch => no CORS issue
    const response = await fetch(remoteUrl)
    if (!response.ok) {
      return NextResponse.json(
        { error: `Upstream error: ${response.statusText}` },
        { status: response.status }
      )
    }

    const data = await response.json()
    return NextResponse.json(data)
  } catch (err) {
    console.error("Error in /api/all-accounts route:", err)
    return NextResponse.json({ error: "Internal server error" }, { status: 500 })
  }
}

----------------------------------------

File: app/api\auth\login\route.tsx
----------------------------------------
'use server';
import { NextResponse } from 'next/server';
import pool from '@/utils/db';
import bcrypt from 'bcryptjs';

export async function POST(request: Request) {
  try {
    const body = await request.json();
    const { email, password } = body;
    if (!email || !password) {
      return NextResponse.json({ error: 'Email and password are required' }, { status: 400 });
    }
    const client = await pool.connect();
    const userRes = await client.query('SELECT * FROM users WHERE email = $1', [email]);
    client.release();
    if (userRes.rowCount === 0) {
      return NextResponse.json({ error: 'Invalid credentials' }, { status: 401 });
    }
    const user = userRes.rows[0];
    const passwordMatch = bcrypt.compareSync(password, user.password_hash);
    if (!passwordMatch) {
      return NextResponse.json({ error: 'Invalid credentials' }, { status: 401 });
    }
    // Return user data (do not include the password hash)
    const userData = { user_id: user.user_id, email: user.email };
    return NextResponse.json({ success: true, user: userData }, { status: 200 });
  } catch (error) {
    console.error('Error in login:', error);
    return NextResponse.json({ error: 'Error logging in' }, { status: 500 });
  }
}

----------------------------------------

File: app/api\auth\signup\route.tsx
----------------------------------------
'use server';
import { NextResponse } from 'next/server';
import pool from '@/utils/db';
import bcrypt from 'bcryptjs';

export async function POST(request: Request) {
  try {
    const body = await request.json();
    const { email, password, company, reason } = body;
    if (!email || !password) {
      return NextResponse.json({ error: 'Email and password are required' }, { status: 400 });
    }
    const client = await pool.connect();
    // Check if the user already exists
    const userCheck = await client.query('SELECT * FROM users WHERE email = $1', [email]);
    if (userCheck && userCheck.rowCount !== null && userCheck.rowCount > 0) {
      client.release();
      return NextResponse.json({ error: 'User already exists' }, { status: 400 });
    }
    // Hash the password
    const salt = bcrypt.genSaltSync(10);
    const password_hash = bcrypt.hashSync(password, salt);
    // Insert new user
    const result = await client.query(
      `INSERT INTO users (email, password_hash, company, reason) 
       VALUES ($1, $2, $3, $4) RETURNING user_id, email`,
      [email, password_hash, company, reason]
    );
    client.release();
    return NextResponse.json({ success: true, user: result.rows[0] }, { status: 200 });
  } catch (error) {
    console.error('Error in signup:', error);
    return NextResponse.json({ error: 'Error signing up' }, { status: 500 });
  }
}

----------------------------------------

File: app/api\company-facts\route.tsx
----------------------------------------
// app/api/company-facts/route.ts

import { NextResponse } from "next/server"

// We'll assume you're using .env for the base URL and token.
// If not, you can hardcode them here.
const BASE_URL = process.env.NEXT_PUBLIC_EXTERNAL_API_BASE_URL
const API_TOKEN = process.env.NEXT_PUBLIC_EXTERNAL_API_TOKEN

export async function GET(request: Request) {
  try {
    // 1) Extract query params from the incoming request
    const { searchParams } = new URL(request.url)
    // e.g. "320193"
    const cik = searchParams.get("cik") ?? ""

    // 2) Build the remote URL
    const remoteUrl = `${BASE_URL}/company_facts?cik=${cik}&api_token=${API_TOKEN}`

    console.log("Fetching from:", remoteUrl)

    // 3) Fetch from the external API (server-to-server, no CORS issues here)
    const response = await fetch(remoteUrl, {
      method: "GET",
    })

    if (!response.ok) {
      // e.g. 404, 500, ...
      return NextResponse.json(
        { error: `Upstream error: ${response.statusText}` },
        { status: response.status }
      )
    }

    // 4) Return the JSON response to the client
    const data = await response.json()
    return NextResponse.json(data)
  } catch (err) {
    return NextResponse.json({ error: "Internal server error" }, { status: 500 })
  }
}

----------------------------------------

File: app/api\files\route.tsx
----------------------------------------
import { NextResponse } from 'next/server';
import pool from '@/utils/db';

export async function POST(request: Request) {
  const client = await pool.connect();
  try {
    const userId = request.headers.get('x-user-id');
    if (!userId) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const formData = await request.formData();
    const files = formData.getAll('files') as File[];
    
    if (!files || files.length === 0) {
      return NextResponse.json({ error: 'No files provided' }, { status: 400 });
    }

    const insertedFiles = [];
    
    for (const file of files) {
      const buffer = Buffer.from(await file.arrayBuffer());
      const result = await client.query(
        `INSERT INTO files 
         (user_id, file_name, file_type, file_data, session_id)
         VALUES ($1, $2, $3, $4, $5)
         RETURNING file_id`,
         [userId, file.name, file.type, buffer, request.headers.get('x-session-id')]
      );
      insertedFiles.push(result.rows[0].file_id);
    }

    return NextResponse.json({ success: true, fileIds: insertedFiles });
  } catch (error) {
    console.error('File upload error:', error);
    return NextResponse.json({ error: 'File upload failed' }, { status: 500 });
  } finally {
    client.release();
  }
}

export async function GET() {
  try {
    const client = await pool.connect();
    const result = await client.query(`SELECT * FROM files;`);
    client.release();

    return NextResponse.json(result.rows);
  } catch (error) {
    console.error(error);
    return NextResponse.json({ error: 'Error fetching files' }, { status: 500 });
  }
}

----------------------------------------

File: app/api\files\[fileId]\route.tsx
----------------------------------------
import { NextResponse } from 'next/server';
import pool from '@/utils/db';


export async function GET(
  request: Request,
  { params }: { params: { fileId: string } }
) {
  const client = await pool.connect();
  try {
    const fileId = parseInt(params.fileId);
    if (isNaN(fileId)) {
      return NextResponse.json({ error: 'Invalid file ID' }, { status: 400 });
    }

    const result = await client.query(
      `SELECT file_name, file_type, file_data 
       FROM files 
       WHERE file_id = $1`,
      [fileId]
    );

    if (result.rowCount === 0) {
      return NextResponse.json({ error: 'File not found' }, { status: 404 });
    }

    const file = result.rows[0];
    return new NextResponse(file.file_data, {
      headers: {
        'Content-Type': file.file_type,
        'Content-Disposition': `attachment; filename="${file.file_name}"`
      }
    });
  } catch (error) {
    console.error('File download error:', error);
    return NextResponse.json({ error: 'File download failed' }, { status: 500 });
  } finally {
    client.release();
  }
}

export async function DELETE(
  request: Request,
  { params }: { params: { fileId: string } }
) {
  let client;
  try {
    client = await pool.connect();
    const fileId = parseInt(params.fileId, 10);
    if (isNaN(fileId)) {
      return NextResponse.json({ error: 'Invalid file ID' }, { status: 400 });
    }

    // Remove any extractions for this file, then remove the file itself
    await client.query('DELETE FROM extractions WHERE file_id = $1', [fileId]);
    await client.query('DELETE FROM files WHERE file_id = $1', [fileId]);

    client.release();
    return NextResponse.json({ success: true }, { status: 200 });
  } catch (error) {
    console.error('Error deleting file:', error);
    if (client) client.release();
    return NextResponse.json({ error: 'Error deleting file' }, { status: 500 });
  }
}

----------------------------------------

File: app/api\financial-data\route.tsx
----------------------------------------
// app/api/financial-data/route.ts
import { NextResponse } from "next/server"
import { Pool } from 'pg';

const pool = new Pool({
    port: 5432,
    host: 'localhost',
    user: 'postgres',
    password: '1234',
    database: 'sec_financial_data',
});

export async function GET(request: Request) {
  try {
    // 1) Parse query params from the URL
    const { searchParams } = new URL(request.url)
    const nameParam = (searchParams.get("name") ?? "").trim().toLowerCase()
    const tickerParam = (searchParams.get("ticker") ?? "").trim().toLowerCase()
    const cikParam = (searchParams.get("cik") ?? "").trim()

    // 2) Prepare placeholders.
    //    For name, we use a LIKE pattern if it's not empty: '%<name>%'
    //    For ticker, we do an exact match but case-insensitive, so we store it in lowercase and compare with LOWER(t.ticker).
    //    For cik, we do an exact match.
    const nameFilter = nameParam ? `%${nameParam}%` : ""
    const tickerFilter = tickerParam // empty if none provided
    const cikFilter = cikParam // empty if none provided

    // 3) Connect to the database
    const client = await pool.connect()

    // 4) Build and run the query
    //    Explanation:
    //    - LEFT JOIN `tickers` so we can gather possible tickers per `companies` row
    //    - Filter with a combination of name, ticker, and/or cik
    //    - If the corresponding parameter is empty, we skip that filter
    //    - Group by c.cik, c.name so we can do array_agg on the tickers
    const sql = `
      SELECT
        c.cik,
        c.name,
        ARRAY_AGG(t.ticker) AS tickers
      FROM companies c
      LEFT JOIN tickers t ON c.cik = t.cik
      WHERE
        ($1 = '' OR LOWER(c.name) LIKE $1)
        AND ($2 = '' OR LOWER(t.ticker) = $2)
        AND ($3 = '' OR c.cik = $3)
      GROUP BY c.cik, c.name
      ORDER BY c.name ASC
      LIMIT 50;
    `

    const result = await client.query(sql, [
      nameFilter,
      tickerFilter,
      cikFilter,
    ])

    client.release()

    // 5) Return JSON response
    return NextResponse.json(result.rows)
  } catch (error) {
    console.error("Error in /api/financial-data:", error)
    return NextResponse.json(
      { error: "Internal server error" },
      { status: 500 }
    )
  }
}

----------------------------------------

File: app/api\llm\route.tsx
----------------------------------------
// app/api/llm/route.ts
import { NextResponse } from 'next/server'
import pool from '@/utils/db';

export const dynamic = 'force-dynamic';

interface DeepSeekError {
  error: {
    message: string;
    type: string;
    code: string;
  };
}

export async function POST(req: Request) {
  const body = await req.json();
  const { prompt, context, history, model, format, requestType } = body || {};

  if (!prompt || typeof prompt !== 'string') {
    return NextResponse.json({ error: "Invalid prompt" }, { status: 300 });
  }

  const DEVELOPMENT = process.env.NEXT_PUBLIC_LLM_DEV_MODE === 'true';
  const userId = req.headers.get('x-user-id');

  if (DEVELOPMENT) {
    await new Promise(res => setTimeout(res, 500));
    return NextResponse.json({
      content: `[MOCK RESPONSE] ${model || 'no-model'} response...`,
      tokensUsed: 42
    });
  }

  try {
    
    if (model?.startsWith('deepseek:')) {
      const deepseekKey = process.env.DEEPSEEK_API_KEY;
      if (!deepseekKey) {
        console.error('DeepSeek API key missing');
        return NextResponse.json(
          { error: 'DeepSeek API key not configured' },
          { status: 500 }
        );
      }

      const modelName = model.replace('deepseek:', '');
      const messages = [
        { role: 'system', content: context || 'You are a helpful assistant.' },
        ...(Array.isArray(history) ? history : []),
        { role: 'user', content: prompt }
      ];

      const requestPayload = {
        model: modelName,
        messages,
        temperature: 0.1,
        max_tokens: 8000,
        stream: false,
        //response_format: format === 'json' ? { type: 'json_object' } : undefined
      };

      const startTime = Date.now();
      const response = await fetch('https://api.deepseek.com/v1/chat/completions', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${deepseekKey}`
        },
        body: JSON.stringify(requestPayload)
      });

      const responseTime = Date.now() - startTime;
      const responseText = await response.text();
      
      

      if (!response.ok) {
        console.error('DeepSeek API Error Details:', {
          status: response.status,
          headers: Object.fromEntries(response.headers.entries()),
          body: responseText
        });
        return NextResponse.json(
          { error: `DeepSeek API Error: ${response.statusText}`, details: responseText },
          { status: 500 }
        );
      }

      try {
        if (requestType === 'consolidation') {
        console.log('Consolidation Response:', responseText);
        }

        const data = JSON.parse(responseText);

        let content = '';

        if (requestType === 'summarize') {
          // For summaries, use the message content directly
          content = data.choices[0].message.content;
        } else if (requestType === 'consolidation' || requestType === 'extract') {
           // For structured data, clean JSON formatting
          const rawContent = data.choices[0].message.content;
          content = rawContent.replace(/```json\s*/gi, '').replace(/```/g, '').trim();
        } else {
          content = data.choices[0].message.content;
        }

        return NextResponse.json({
          content: content,
          tokensUsed: data.usage?.total_tokens || 0
        });
      } catch (parseError) {
        if (requestType === 'summarize') {
          return NextResponse.json({
            content: responseText, // Return raw text if JSON parse fails
            tokensUsed: 0
          });
        }
        console.error('Response JSON Parse Error:', parseError);
        return NextResponse.json(
          { error: 'Failed to parse API response', response: responseText },
          { status: 500 }
        );
      }
    }

    if (model?.startsWith('openai:')) {
      // commented for now
    }

    return NextResponse.json(
      { error: 'Unsupported model provider' },
      { status: 400 }
    );

  } catch (error) {
    console.error('LLM Processing Error:', error);
    return NextResponse.json(
      { error: 'LLM processing failed', details: error instanceof Error ? error.message : String(error) },
      { status: 500 }
    );
  }
}
----------------------------------------

File: app/api\search\route.tsx
----------------------------------------
// app/api/search/route.ts
import { NextResponse } from 'next/server';
import pool from '../../../utils/db';

export async function GET(request: Request) {
  const { searchParams } = new URL(request.url);
  const query = searchParams.get('query') || '';

  try {
    const client = await pool.connect();
    const searchQuery = `
      SELECT 
        c.cik,
        c.name,
        ARRAY_AGG(t.ticker) as tickers,
        ts_rank(to_tsvector('english', c.name), plainto_tsquery('english', $1)) as rank
      FROM companies c
      LEFT JOIN tickers t ON c.cik = t.cik
      WHERE 
        to_tsvector('english', c.name) @@ plainto_tsquery('english', $1) OR
        t.ticker = $1 OR
        c.cik = $1
      GROUP BY c.cik, c.name
      ORDER BY rank DESC
      LIMIT 10;
    `;

    const result = await client.query(searchQuery, [query]);
    client.release();

    return NextResponse.json(result.rows.map(row => ({
      ...row,
      searchTerm: row.tickers.includes(query.toUpperCase()) ? query.toUpperCase() : row.cik === query ? query : row.name
    })));
  } catch  {
    return NextResponse.json(
      { error: 'Internal server error' },
      { status: 500 }
    );
  }
}
----------------------------------------

File: app/api\session-file\route.tsx
----------------------------------------
import { NextResponse } from 'next/server';
import fs from 'fs';
import path from 'path';
import mime from 'mime'; // install via `npm install mime` if you want to do more robust MIME detection

export async function GET(request: Request) {
  try {
    const { searchParams } = new URL(request.url);
    const sessionId = searchParams.get('sessionId');
    const filePath = searchParams.get('filePath');

    if (!sessionId || !filePath) {
      return NextResponse.json(
        { error: 'Missing sessionId or filePath' },
        { status: 400 }
      );
    }

    // Construct the absolute path on disk
    const absolutePath = path.join(
      process.cwd(),
      'data',
      sessionId,
      decodeURIComponent(filePath) // Add URI decoding
    );

    console.log('Serving file:', absolutePath);

    if (!fs.existsSync(absolutePath)) {
      return NextResponse.json({ error: 'File not found' }, { status: 404 });
    }

    // Read file from disk
    const fileBuffer = fs.readFileSync(absolutePath);

    // Infer MIME type from the filename extension, or fall back to octet-stream
    const mimeType = mime.getType(absolutePath) || 'application/octet-stream';

    const headers = {
      'Content-Type': mimeType,
      'Content-Disposition': `inline; filename="${path.basename(absolutePath)}"`,
    };
    // Add proper PDF content disposition
    if (mimeType === 'application/pdf') {
      headers['Content-Disposition'] = `inline; filename="${path.basename(absolutePath)}"`;
    } else {
      headers['Content-Disposition'] = `attachment; filename="${path.basename(absolutePath)}"`;
    }

    // Return the file bytes in the response
    return new NextResponse(fileBuffer, {
      headers: headers,
    });
  } catch (error) {
    console.error('Error serving file:', error);
    return NextResponse.json({ error: 'File serving error' }, { status: 500 });
  }
}

----------------------------------------

File: app/api\sessions\route.tsx
----------------------------------------
// app/api/sessions/route.tsx
import { NextResponse } from 'next/server';
import pool from '../../../utils/db';
// app/api/sessions/route.tsx
export async function GET(request: Request) {
  const client = await pool.connect();
  try {
    const userId = request.headers.get('x-user-id');
    if (!userId || isNaN(parseInt(userId))) { // Add numeric validation
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }
  

    const result = await client.query(`
      SELECT 
        s.session_id,
        s.session_name,
        s.created_at,
        (SELECT COUNT(*)::int FROM files f WHERE f.session_id = s.session_id) AS file_count
      FROM sessions s
      WHERE s.user_id = $1
      ORDER BY s.created_at DESC
    `, [userId]);


    
    const sessions = result.rows.map((row) => ({
      session_id: row.session_id,
      session_name: row.session_name,
      created_at: row.created_at,
      file_count: row.file_count
    }));

    return NextResponse.json({ sessions });
  } catch (error) {
    console.error('Session load error:', error);
    //alert(error);
    return NextResponse.json({ error: 'Failed to load sessions' }, { status: 500 });
  } finally {
    client.release();
  }
}



export async function POST(request: Request) {
  const client = await pool.connect();
  await client.query('BEGIN');
  try {
    const userId = request.headers.get('x-user-id');
    if (!userId) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const { sessionName } = await request.json();


    //columns  session_id | user_id | session_name | created_at | expires_at
    const result = await client.query(`
      INSERT INTO sessions (user_id, session_name)
      VALUES ($1, $2)
      RETURNING session_id, created_at
    `, [userId, sessionName]);

   
    const sessionId = result.rows[0].session_id;

    await client.query('COMMIT');
    return NextResponse.json({
      success: true,
      session_id: sessionId,
      created_at: result.rows[0].created_at
    });
  } catch (error) {
    await client.query('ROLLBACK');
    console.error('Session save error:', error);
    return NextResponse.json({ error: 'Failed to save session' }, { status: 500 });
  } finally {
    client.release();
  }
}
----------------------------------------

File: app/api\sessions\[sessionId]\route.tsx
----------------------------------------
// app/api/sessions/[sessionId]/route.tsx
import { NextResponse } from 'next/server';
import pool from '@/utils/db';
import fs from 'fs';
import path from 'path';

export async function GET(
  request: Request,
  { params }: { params: { sessionId: string } }
) {
  const client = await pool.connect();
  try {
    const userId = request.headers.get('x-user-id');
    if (!userId) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }
    const sId = parseInt(params.sessionId, 10);
    if (isNaN(sId)) {
      return NextResponse.json({ error: 'Invalid session ID' }, { status: 400 });
    }

    const res = await client.query(
      `SELECT session_id, session_name, created_at
         FROM sessions
        WHERE session_id = $1 AND user_id = $2`,
      [sId, userId]
    );
    if (res.rowCount === 0) {
      return NextResponse.json({ error: 'Session not found' }, { status: 404 });
    }
    const session = res.rows[0];
    return NextResponse.json({ session });
  } catch (error) {
    console.error('Error fetching session:', error);
    return NextResponse.json({ error: 'Error fetching session' }, { status: 500 });
  } finally {
    client.release();
  }
}

export async function DELETE(
  request: Request,
  { params }: { params: { sessionId: string } }
) {
  const client = await pool.connect();
  await client.query('BEGIN');
  try {
    const userId = request.headers.get('x-user-id');
    if (!userId) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }
    const sId = parseInt(params.sessionId, 10);
    if (isNaN(sId)) {
      return NextResponse.json({ error: 'Invalid session ID' }, { status: 400 });
    }
    // Optionally, remove the session reference from files (set session_id to NULL)
    await client.query(
      `UPDATE files SET session_id = NULL WHERE session_id = $1 AND user_id = $2`,
      [sId, userId]
    );
    const deleteResult = await client.query(
      `DELETE FROM sessions WHERE session_id = $1 AND user_id = $2`,
      [sId, userId]
    );
    if (deleteResult.rowCount === 0) {
      // Nothing to delete or unauthorized
      await client.query('ROLLBACK');
      return NextResponse.json(
        { error: 'Session not found or not authorized' },
        { status: 404 }
      );
    }

    await client.query('COMMIT');

     // 3) Remove the session folder from disk (best-effort)
    // data/<sessionId> is the folder holding heavyData.json + /files
    const sessionPath = path.join(process.cwd(), 'data', String(sId));
    try {
      // Node 14 and below do not support fs.rmSync, so if you need older Node, use rmdirSync.
      fs.rmSync(sessionPath, { recursive: true, force: true });
      console.log(`Deleted directory: ${sessionPath}`);
    } catch (err) {
      // Not critical if folder removal fails – but we log it.
      console.error(`Failed to remove folder ${sessionPath}:`, err);
    }

    return NextResponse.json({ success: true });
  } catch (error) {
    await client.query('ROLLBACK');
    console.error('Error deleting session:', error);
    return NextResponse.json({ error: 'Error deleting session' }, { status: 500 });
  } finally {
    client.release();
  }
}

----------------------------------------

File: app/api\store-heavy-data\route.tsx
----------------------------------------
// app/api/store-heavy-data/route.ts
import { NextResponse } from 'next/server';
import fs from 'fs';
import path from 'path';
import { FileNode } from '@/components/FileTree';

export async function POST(request: Request) {
  try {
    const { sessionId, heavyData } = await request.json();
    if (!sessionId) {
      return NextResponse.json({ error: 'sessionId is required' }, { status: 400 });
    }

    // 1) Create the directory structure: data/sessionId/files
    const dataDir = path.join(process.cwd(), 'data', sessionId.toString());
    const filesDir = path.join(dataDir, 'files');
    if (!fs.existsSync(dataDir)) {
      fs.mkdirSync(dataDir, { recursive: true });
    }
    if (!fs.existsSync(filesDir)) {
      fs.mkdirSync(filesDir);
    }

    // 2) For each file node in fileTree, decode base64 -> raw file
    function storeFilesRecursively(nodes: FileNode[]): FileNode[] {
      return nodes.map((node, idx) => {
        if (node.type === 'folder' && node.children) {
          return { ...node, children: storeFilesRecursively(node.children) };
        }
        if (node.type === 'file' && node.base64Data) {
          // decode base64
          const buffer = Buffer.from(node.base64Data, 'base64');
          // create a unique filename. You can also keep the original name if you prefer
          // but we add idx or a timestamp to avoid collisions:
          const safeName = node.name.replace(/[^\w\d.]+/g, '_');
          const fileName = `file_${Date.now()}_${idx}_${safeName}`;
          const filePath = path.join(filesDir, fileName);

          // 3) Write the file to data/sessionId/files/
          fs.writeFileSync(filePath, buffer);

          // 4) Remove base64Data from the node, and add localPath
          return {
            ...node,
            base64Data: undefined,
            rawData: undefined,
            localPath: `files/${fileName}`
          };
        }
        return node;
      });
    }

    // If there's a fileTree, store each file on disk
    let updatedFileTree: FileNode[] = [];
    if (heavyData.fileTree) {
      updatedFileTree = storeFilesRecursively(heavyData.fileTree);
    }

    // 5) Overwrite heavyData.fileTree with the updated one
    const filePath = path.join(dataDir, 'heavyData.json');
    const existingData = fs.existsSync(filePath) 
                ? JSON.parse(fs.readFileSync(filePath, 'utf-8'))
                : {};

    const finalHeavyData = {
      ...existingData,
      ...heavyData,
      fileTree: updatedFileTree
    };

    
    fs.writeFileSync(filePath, JSON.stringify(finalHeavyData, null, 2));





    return NextResponse.json({ success: true, filePath });
  } catch (error) {

    return NextResponse.json(
      { error: 'Failed to save heavy data' + error },
      { status: 500 }
    );
  }
}

export async function GET(request: Request) {
  const { searchParams } = new URL(request.url);
  const sessionId = searchParams.get('sessionId');

  if (!sessionId) {
    return NextResponse.json({ error: 'sessionId is required' }, { status: 400 });
  }

  try {
    const dataDir = path.join(process.cwd(), 'data', sessionId);
    const filePath = path.join(dataDir, 'heavyData.json');
    if (!fs.existsSync(filePath)) {
      return NextResponse.json({ error: 'No heavyData found' }, { status: 404 });
    }

    const data = fs.readFileSync(filePath, 'utf-8');
    return NextResponse.json(JSON.parse(data));
  } catch (error) {
    console.error('Error reading heavy data:', error);
    return NextResponse.json({ error: 'Heavy data not found' }, { status: 404 });
  }
}

----------------------------------------

File: app/api\submission-history\route.tsx
----------------------------------------
// app/api/submission-history/route.ts

import { NextResponse } from "next/server"

const BASE_URL = process.env.NEXT_PUBLIC_EXTERNAL_API_BASE_URL
const API_TOKEN = process.env.NEXT_PUBLIC_EXTERNAL_API_TOKEN

export async function GET(request: Request) {
  try {
    const { searchParams } = new URL(request.url)
    const cik = searchParams.get("cik") ?? ""

    const remoteUrl = `${BASE_URL}/submission_history?cik=${cik}&api_token=${API_TOKEN}`
    const response = await fetch(remoteUrl, { method: "GET" })
    if (!response.ok) {
      return NextResponse.json(
        { error: `Upstream error: ${response.statusText}` },
        { status: response.status }
      )
    }

    const data = await response.json()
    return NextResponse.json(data)
  } catch (err) {
    console.error("Error in /api/submission-history route:", err)
    return NextResponse.json({ error: "Internal server error" }, { status: 500 })
  }
}

----------------------------------------

File: app/api\test\route.tsx
----------------------------------------
// app/api/test/route.ts
import { NextResponse } from 'next/server';
import pool from '@/utils/db';

export async function GET() {
  try {
    const client = await pool.connect();
    const result = await client.query('SELECT * FROM files ORDER BY file_id;');
    client.release();

    return NextResponse.json(result.rows);
  } catch (error) {
    console.error('Error fetching data', error);
    return NextResponse.json({ error: 'Error fetching data' }, { status: 500 });
  }
}

----------------------------------------

File: app/api\uploads\route.tsx
----------------------------------------
// app/api/uploads/route.ts
import { NextResponse } from 'next/server';
import pool from '@/utils/db';
import { FileNode } from '@/components/FileTree';

export async function GET(request: Request) {
  const userId = request.headers.get('x-user-id');
  if (!userId) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }

  try {
    const client = await pool.connect();
    // 1) Fetch all uploads for this user:
    const uploadsResult = await client.query(`
      SELECT upload_id, upload_name, created_at
      FROM uploads
      WHERE user_id = $1
      ORDER BY created_at DESC
    `, [userId]);

    const uploads = uploadsResult.rows;
    client.release();
    return NextResponse.json({ uploads });
  } catch (error) {
    console.error('Error fetching uploads:', error);
    return NextResponse.json({ error: 'Error fetching uploads' }, { status: 500 });
  }
}

export async function POST(request: Request) {
  let client;
  try {
    client = await pool.connect();
    const body = await request.json();
    const { uploadName, fileTree, extractedTexts, summaries, chatHistory } = body;

    // 1) Validate user ID from headers
    const userId = request.headers.get('x-user-id');
    if (!userId) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    // 2) Validate required fields
    if (!uploadName) {
      return NextResponse.json({ error: 'uploadName is required' }, { status: 400 });
    }

    // 3) Create a new "upload" row
    const insertUploadRes = await client.query(
      `INSERT INTO uploads (user_id, upload_name)
       VALUES ($1, $2)
       RETURNING upload_id`,
      [userId, uploadName]
    );
    const newUploadId = insertUploadRes.rows[0].upload_id;

    // 4) Gather all files from the fileTree
    const filesToInsert: Array<{
      fullPath: string;
      fileName: string;
      fileDataBase64?: string;
      mimeType: string;
    }> = [];

    function traverseTree(nodes: FileNode[]) {
      for (const node of nodes) {
        if (node.type === 'file') {
          filesToInsert.push({
            fullPath: node.fullPath || '',
            fileName: node.name,
            fileDataBase64: node.base64Data, // base64 string from the frontend
            mimeType: node.mimeType || 'application/octet-stream'
          });
        }
        if (node.children?.length) {
          traverseTree(node.children);
        }
      }
    }
    traverseTree(fileTree || []);

    // 5) Insert each file row + extraction if applicable
    for (const file of filesToInsert) {
      const fileDataBuffer = file.fileDataBase64
        ? Buffer.from(file.fileDataBase64, 'base64')
        : null;

      // Insert a row in "files"
      const insertFileRes = await client.query(
        `INSERT INTO files (upload_id, file_name, file_path, mime_type, file_data, is_extracted)
         VALUES ($1, $2, $3, $4, $5, $6)
         RETURNING file_id`,
        [
          newUploadId,
          file.fileName,
          file.fullPath,
          file.mimeType,
          fileDataBuffer,
          false
        ]
      );

      const fileId = insertFileRes.rows[0].file_id;

      // If there's text or summary, insert into "extractions"
      const extractedText = extractedTexts?.[file.fullPath];
      const summary = summaries?.[file.fullPath];
      if (extractedText || summary) {
        // Mark file as extracted
        await client.query(
          `UPDATE files SET is_extracted = TRUE WHERE file_id = $1`,
          [fileId]
        );

        // Insert into "extractions"
        await client.query(
          `INSERT INTO extractions (file_id, extracted_text, summarized_text)
           VALUES ($1, $2, $3)`,
          [fileId, extractedText || null, summary || null]
        );
      }
    }

    client.release();

    // Return the upload_id and chatHistory (if any)
    return NextResponse.json(
      { upload_id: newUploadId, chatHistory },
      { status: 200 }
    );
  } catch (error) {
    console.error('Error creating new upload:', error);
    if (client) client.release();
    return NextResponse.json(
      { error: 'Error creating new upload' },
      { status: 500 }
    );
  }
}

----------------------------------------

File: app/api\uploads\[uploadId]\route.tsx
----------------------------------------

import { NextResponse } from 'next/server';
import pool from '@/utils/db';
import { FileNode } from '@/components/FileTree';


export async function DELETE(request: Request,{ params }: { params: { uploadId: string } }) {
  let client;
  try {
    client = await pool.connect();
    const uploadId = parseInt(params.uploadId,10);
    if(isNaN(uploadId)) {
      return NextResponse.json({ error:'Invalid upload ID'},{ status:400 });
    }
    //1) Find all files for this upload
    const fileRes = await client.query(
      'SELECT file_id FROM files WHERE upload_id=$1',[uploadId]
    );
    const fileIds = fileRes.rows.map(r=>r.file_id);
    //2) Delete extractions for these files
    if(fileIds.length>0) {
      await client.query(
        'DELETE FROM extractions WHERE file_id=ANY($1)',
        [fileIds]
      );
    }
    //3) Delete files themselves
    await client.query('DELETE FROM files WHERE upload_id=$1',[uploadId]);
    //4) Finally delete the upload
    await client.query('DELETE FROM uploads WHERE upload_id=$1',[uploadId]);
    client.release();
    return NextResponse.json({ success:true },{ status:200 });
  } catch(error) {
    console.error('Error deleting entire upload:',error);
    if(client) client.release();
    return NextResponse.json({ error:'Error deleting upload'},{ status:500 });
  }
}


export async function PATCH(request: Request,{ params }: { params: { uploadId: string } }) {
  let client;
  try {
    client = await pool.connect();
    const uploadId = parseInt(params.uploadId, 10);
    if (isNaN(uploadId)) {
      return NextResponse.json({ error: 'Invalid upload ID' }, { status: 400 });
    }

    const body = await request.json();
    const { fileTree, extractedTexts, summaries } = body;
    const filesToInsert: Array<{
      fullPath: string;
      fileName: string;
      fileDataBase64?: string;
      mimeType: string;
    }> = [];

    function traverseTree(nodes: FileNode[]) {
      for (const node of nodes) {
        if (node.type === 'file') {
          filesToInsert.push({
            fullPath: node.fullPath || '',
            fileName: node.name,
            fileDataBase64: node.base64Data, // from front end
            mimeType: node.mimeType || 'application/octet-stream'
          });
        }
        if (node.children?.length) traverseTree(node.children);
      }
    }
    traverseTree(fileTree);

    // For each file, either insert or update
    for (const file of filesToInsert) {
      const existingFileRes = await client.query(
        `SELECT file_id FROM files WHERE upload_id = $1 AND file_path = $2`,
        [uploadId, file.fullPath]
      );
      let fileId: number;
      if (existingFileRes.rowCount && existingFileRes.rowCount > 0) {
        fileId = existingFileRes.rows[0].file_id;
        // Potentially update file_data if new base64 data is provided
        if (file.fileDataBase64) {
          const fileDataBuffer = Buffer.from(file.fileDataBase64, 'base64');
          await client.query(
            `UPDATE files
                SET file_data = $2, mime_type=$3
              WHERE file_id = $1`,
            [fileId, fileDataBuffer, file.mimeType]
          );
        }
      } else {
        // Insert new file row
        const fileDataBuffer = file.fileDataBase64
          ? Buffer.from(file.fileDataBase64, 'base64')
          : null;
        const insertRes = await client.query(
          `INSERT INTO files (upload_id, file_name, file_path, mime_type, file_data, is_extracted)
           VALUES ($1, $2, $3, $4, $5, $6)
           RETURNING file_id`,
          [
            uploadId,
            file.fileName,
            file.fullPath,
            file.mimeType,
            fileDataBuffer,
            false
          ]
        );
        fileId = insertRes.rows[0].file_id;
      }

      // Check if we have extraction for that path
      const extractedText = extractedTexts[file.fullPath];
      const summary = summaries[file.fullPath];
      if (extractedText || summary) {
        // Mark file as extracted
        await client.query(`UPDATE files SET is_extracted = TRUE WHERE file_id = $1`, [fileId]);
        // Upsert extraction
        const existingExtractRes = await client.query(
          `SELECT extraction_id FROM extractions WHERE file_id=$1`,
          [fileId]
        );
        if (existingExtractRes.rowCount && existingExtractRes.rowCount > 0) {
          await client.query(
            `UPDATE extractions
                SET extracted_text=$2,
                    summarized_text=$3,
                    updated_at=NOW()
              WHERE file_id=$1`,
            [fileId, extractedText || null, summary || null]
          );
        } else {
          await client.query(
            `INSERT INTO extractions (file_id, extracted_text, summarized_text)
             VALUES ($1,$2,$3)`,
            [fileId, extractedText || null, summary || null]
          );
        }
      }
    }

    client.release();
    return NextResponse.json({ success: true, message: 'Upload updated.' });
  } catch (error) {
    console.error('Error updating upload:', error);
    if (client) client.release();
    return NextResponse.json({ error: 'Error updating upload' }, { status: 500 });
  }
}

----------------------------------------

File: app/login\page.tsx
----------------------------------------
// app/login/page.tsx
'use client';

import { useState } from 'react';
import { useRouter } from 'next/navigation';
import Link from 'next/link';
import Navbar from '@/components/Navbar';

export default function LoginPage() {
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [error, setError] = useState<string | null>(null);
  const router = useRouter();

  const handleLogin = async (e: React.FormEvent) => {
    e.preventDefault();
    setError(null);
    if (!email || !password) {
      setError('Please enter both email and password');
      return;
    }
    try {
      const res = await fetch('/api/auth/login', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ email, password }),
      });
      const data = await res.json();
      if (!res.ok) {
        throw new Error(data.error || 'Login failed');
      }
      // Save login details from the response
      localStorage.setItem('loggedIn', 'true');
      localStorage.setItem('userEmail', data.user.email);
      localStorage.setItem('userId', String(data.user.user_id));
      router.push('/dashboard');
    } catch (err) {
      console.error('Login Error:', err);
      setError('Invalid email or password');
    }
  };

  return (
    <div className="min-h-screen bg-gray-50">
      <Navbar />
      <main className="flex items-center justify-center px-4 py-12">
        <div className="w-full max-w-md bg-white rounded-lg shadow-md p-8">
          <h1 className="text-2xl font-bold text-center text-blue-600 mb-6">Welcome Back</h1>
          {error && <p className="text-red-600 text-sm">{error}</p>}
          <form onSubmit={handleLogin} className="space-y-4">
            <div>
              <label className="block text-gray-700 text-sm font-medium mb-1">Email</label>
              <input
                type="email"
                className="w-full border border-gray-300 rounded-md p-2"
                value={email}
                onChange={(e) => setEmail(e.target.value)}
                required
                placeholder="Enter your email"
              />
            </div>
            <div>
              <label className="block text-gray-700 text-sm font-medium mb-1">Password</label>
              <input
                type="password"
                className="w-full border border-gray-300 rounded-md p-2"
                value={password}
                onChange={(e) => setPassword(e.target.value)}
                required
                placeholder="Enter your password"
              />
            </div>
            <button
              type="submit"
              className="w-full bg-blue-600 text-white py-2 rounded-md hover:bg-blue-700 transition-colors"
            >
              Log In
            </button>
          </form>
          <div className="mt-4 text-center text-sm text-gray-600">
            Don&apos;t have an account?{' '}
            <Link href="/signup" className="text-blue-600 hover:underline">
              Sign Up
            </Link>
          </div>
        </div>
      </main>
    </div>
  );
}

----------------------------------------

